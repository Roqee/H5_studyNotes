# JavaScript学习笔记（pink老师视频）



## 计算机编程基础

### 编程语言

#### 编程

**编程**：就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 

**计算机程序**：就是计算机所执行的一系列的**指令集合**，而程序全部都是用我们所掌握的语言来编写的，所以 人们要控制计算机一定要通过计算机语言向计算机发出命令。 

从事编程的人员，就是**程序员**。 但是一般程序员都比较幽默，为了形容自己的辛苦工作，也成为“码农”， 或者 “程序猿”/ “程序媛”

**注意：**上面所定义的计算机指的是**任何能够执行代码的设备**，可能是智能手机、ATM机、黑莓PI、服务器 等等。



#### 1.2 计算机语言

**计算机语言**指用于**人与计算机之间通讯的语言**，它是人与计算机之间传递信息的**媒介**。 

计算机语言的种类非常的多，总的来说可以分成**机器语言，汇编语言**和**高级语言**三大类。 

实际上计算机最终所执行的都是 **机器语言**，它是由“0”和“1”组成的二进制数，**二进制是计算机语言的基 础**。

```
0=00000000 1=00000001 2=00000010 3=00000011 4=00000100 
5=00000101 6=00000110 7=00000111 8=00001000 9=00001001 
10=00001010
```



#### 1.3 编程语言

可以通过类似于人类语言的 ”语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming  Language）。

编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。 

如今通用的编程语言有两种形式：**汇编语言**和**高级语言**。 

* **汇编语言**和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。 

* **高级语言**主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、 Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。

```
	C语言：puts("你好");
	PHP：echo "你好";
	Java：System.out.println("你好");
	JavaScript： alert("你好"）
```



#### 1.4 翻译器

高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。 翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。 记住1和 0

![image-20211123210525996](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123210525996.png)

#### 1.5 编程语言与标记语言的区别

* **编程语言**有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的 指令，这是主动的。 
* **标记语言**（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。

![image-20211123210647178](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123210647178.png)

##### 总结

1. 计算机可以帮助人类解决某些问题 
2. 程序员利用编程语言编写程序发出指令控制计算机来实现这些任务 
3. 编程语言有机器语言、汇编语言、高级语言 
4. 高级语言需要一个翻译器转换为计算机识别的机器语言 
5.  编程语言是主动的有很强的逻辑性





### 2. 计算机基础

#### 2.1 计算机组成

![image-20211123220708414](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123220708414.png)



![image-20211123220725472](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123220725472.png)

#### 2.2 数据存储

1. 计算机内部使用二进制 0 和 1来表示数据。 
2. 所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。 
3. 所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安 装软件，其实就是把程序文件复制到硬盘中。
4. 硬盘、内存都是保存的二进制数据。



#### 2.3 数据存储单位

bit < byte < kb < GB < TB<..... 

* 位(bit)： 1bit 可以保存一个 0 或者 1 （最小的存储单位） 
* 字节(Byte)：1B = 8b 
* 千字节(KB)：1KB = 1024B
* 兆字节(MB)：1MB = 1024KB 
* 吉字节(GB): 1GB = 1024MB 
* 太字节(TB): 1TB = 1024GB 
*  .....



#### 2.4 程序运行

![image-20211123221207201](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123221207201.png)

1. 打开某个程序时，先从硬盘中把程序的代码加载到内存中 
2. CPU执行内存中的代码 

   **注意**：之所以要内存的一个重要原因，是因为 cpu 运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所    以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械）







***

## 初识JavaScript

### 1. 初识JavaScript

#### 1.1 JavaScript是什么

* 布兰登·艾奇（Brendan Eich，1961年～）。 
* 神奇的大哥用10天完成 JavaScript 设计。 
* 最初命名为 LiveScript，后来在与 Sun 合作之后将其改名为 JavaScript。

* JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思） 
* 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 
* 现在也可以基于 Node.js 技术进行服务器端编程

![image-20211123222032177](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123222032177.png)

#### 1.2 JavaScript 的作用

* 表单动态校验（密码强度检测） （ JS 产生最初的目的 ） 
* 网页特效 
* 服务端开发(Node.js)
* 桌面程序(Electron) 
* App(Cordova)  
* 控制硬件-物联网(Ruff) 
* 游戏开发(cocos2d-js)



#### 1.3 HTML/CSS/JS 的关系

![image-20211123222225409](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123222225409.png)



#### 1.4 浏览器执行 JS 简介

浏览器分成两部分：渲染引擎和 JS 引擎 

* **渲染引擎**：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit 
* **JS 引擎**：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8
* **浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释 每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。**

![image-20211123222428007](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123222428007.png)



#### 1.5 JS 的组成

##### 1. ECMAScript

**ECMAScript** 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广 泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。

![image-20211123222726017](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123222726017.png)

**ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。**

更多参看MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview



##### 2.  DOM ——文档对象模型

**文档对象模型**（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。 通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。



##### 3. BOM ——浏览器对象模型

**BOM** (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行 互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。



#### 1.6 JS 初体验

JS 有3种书写位置，分别为行内、内嵌和外部。

##### 1. 行内式 JS

```
<input type="button" value="点我试试" onclick="alert('Hello World')" />
```

* 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick 
* 注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号 
* 可读性差， 在html中编写JS大量代码时，不方便阅读； 
* 引号易错，引号多层嵌套匹配时，非常容易弄混； 
* 特殊情况下使用



##### 2. 内嵌 JS

```
 <script>
 	alert('Hello World~!');
 </script>
```

* 可以将多行JS代码写到 <script> 标签中
* 内嵌 JS 是学习是常用的方式



##### 3. 外部 JS 文件

```
<script src="my.js"></script>
```

* 利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用 
* 引用外部 JS文件的 script 标签中间不可以写代码 
* 适合于JS 代码量比较大的情况





### 2. Javascript注释

#### 2.1 单行注释

为了提高代码的可读性，JS与CSS一样，也提供了注释功能。JS中的注释主要有两种，分别是单行注释和多行注释。 单行注释的注释方式如下：

```
// 我是一行文字，不想被 JS引擎 执行，所以 注释起来
```

// 用来注释单行文字（ 快捷键 ctrl + / ）

#### 2.2 多行注释

```
/*
 获取用户年龄和姓名
并通过提示框显示出来
*/
```

/* */ 用来注释多行文字（ 默认快捷键 alt + shift + a 

快捷键修改为： ctrl + shift + /  

vscode → 首选项按钮 →键盘快捷方式  →查找 原来的快捷键 →修改为新的快捷键 →回车确认



### 3.JavaScript 输入输出语句

为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：

| 方法             | 说明                           | 归属   |
| ---------------- | ------------------------------ | ------ |
| alert(msg)       | 浏览器弹出警示框               | 浏览器 |
| console.log(msg) | 浏览器控制台打印输出信息       | 浏览器 |
| prompt(info)     | 浏览器弹出输入框，用户可以输入 | 浏览器 |

注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。





***

## 变量

### 1.变量概述

#### 1.1 什么是变量

白话：变量就是一个装东西的盒子。 

通俗：变量是用于存放数据的**容器**。 我们通过 **变量名** 获取数据，甚至数据可以修改。



![image-20211123224834770](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123224834770.png)

#### 1.2 变量在内存中的存储

本质：变量是程序在内存中申请的一块用来存放数据的空间。 

类似我们酒店的房间，一个房间就可以看做是一个变量。 

![image-20211123225037677](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123225037677.png)



### 2. 变量的使用

变量在使用时分为两步： 1. 声明变量 2. 赋值

#### 1. 声明变量

```
// 声明变量 var age; // 声明一个 名称为age 的变量 
```

* var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配 内存空间，不需要程序员管 
* age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间



#### 2. 赋值

```
age = 10; // 给 age 这个变量赋值为 10 
```

* **=** 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思 
* 变量值是程序员保存到变量空间里的值



#### 3. 变量的初始化

```
var age = 18; // 声明变量同时赋值为 18 
```

声明一个变量并赋值， 我们称之为**变量的初始化**





### 1.4 变量的语法扩展

#### 1. 更新变量

一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。

```
var age = 18;
age = 81; // 最后的结果就是81因为18 被覆盖掉了 
```



#### 2. 同时声明多个变量

同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开

```
var age = 10, name = 'zs', sex = 2; 
```



#### 3. 声明变量特殊情况

| 情况                      | 说明          | 结果      |
| ------------------------- | ------------- | --------- |
| var age; console.log(age) | 只声明 不赋值 | undefined |
| console.log(age)          | 不声明 不赋值 | 报错      |
| age = 10;console.log(age) | 不声明 只赋值 | 10        |





### 1.5 变量的命名规范

* 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 
* 严格区分大小写。var app; 和 var App; 是两个变量 
* 不能 以数字开头。 18age 是错误的 
* 不能 是关键字、保留字。例如：var、for、while 
* 变量名必须有意义。 MMD BBD nl → age  
* 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName
* 推荐翻译网站： 有道 爱词



![image-20211123231201201](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123231201201.png)

### 小结

* 为什么需要变量？

  因为我们一些数据需要保存，所以需要变量

  

* 变量是什么？ 

   变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据

  

* 变量的本质是什么? 

  变量是内存里的一块空间，用来存储数据。

  

* 变量怎么使用的？ 

  我们使用变量的时候，一定要声明变量，然后赋值

  声明变量本质是去内存申请空间。

  

* 什么是变量的初始化？ 

  声明变量并赋值我们称之为变量的初始化

  

* 变量命名规范有哪些？

   变量名尽量要规范，见名知意——驼峰命名法

  区分哪些变量名不合法

  

* 交换2个变量值的

   学会交换2个变量







***

## 数据类型

### 1. 数据类型简介

#### 1.1 为什么需要数据类型

在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利 用存储空间，于是定义了不同的数据类型。 

简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。



#### 1.2 变量的数据类型

变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。**JavaScript 是一种弱类型或者说动态语言**。这意味着不用提前声明变量的类型，在程序运行过程中，类型会 被自动确定。

```
var age = 10; // 这是一个数字型
var areYouOk = '是的'; // 
```

在代码运行时，变量的数据类型是由 JS引擎 **根据 = 右边变量值的数据类型来判断** 的，运行完毕之后， 变量就确定了数据类型。 

**JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：**

```
var x = 6; // x 为数字
var x = "Bill"; // x 为字符串
```



#### 1.3 数据类型的分类

JS 把数据类型分为两类：

* 简单数据类型 （Number,String,Boolean,Undefined,Null） 
* 复杂数据类型 （object）



### 2.简单数据类型

#### 2.1 简单数据类型（基本数据类型）

JavaScript 中的简单数据类型及其说明如下：

| 简单数据类型 | 说明                                                    | 默认值    |
| ------------ | ------------------------------------------------------- | --------- |
| Number       | 数字型，包含 整型值和浮点型值，如20、0.21               | 0         |
| Boolean      | 布尔值类型，如true、false，等价于 1 和 0                | false     |
| String       | 字符串类型，如“张三”  注意咱们js 里面，字符串都要带引号 | “”        |
| Undefined    | var a； 声明了变量 a 但是没有给值，此时的 a = undefined | undefined |
| Null         | var a = null；声明了变量 a 为空值                       | null      |



#### 2.2 数字型 Number

JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。 

```
var age = 21; // 整数
var Age = 21.3747; // 小数
```

##### 1. 数字型进制

最常见的进制有二进制、八进制、十进制、十六进制。

```
 // 1.八进制数字序列范围：0~7
var num1 = 07; // 对应十进制的7
var num2 = 019; // 对应十进制的19
var num3 = 08; // 对应十进制的8
 // 2.十六进制数字序列范围：0~9以及A~F
var num = 0xA;
```

现阶段我们只需要记住，**在JS中八进制前面加0，十六进制前面加 0x** 



##### 2. 数字型范围

JavaScript中数值的最大和最小值

```
alert(Number.MAX_VALUE); // 1.7976931348623157e+308
alert(Number.MIN_VALUE); // 5e-324
```

* 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 
* 最小值：Number.MIN_VALUE，这个值为：5e-32



##### 3. 数字型三个特殊值

```javascript
alert(Infinity); // Infinity
alert(-Infinity); // -Infinity
alert(NaN); // NaN
```

* Infinity ，代表无穷大，大于任何数值 
* -Infinity ，代表无穷小，小于任何数值
* NaN ，Not a number，代表一个非数值



##### 4. isNaN()

用来判断一个变量是否为非数字的类型，返回 true 或者 false

![image-20211123233238400](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123233238400.png)

```javascript
var usrAge = 21;
var isOk = isNaN(userAge);
console.log(isNum); // false ，21 不是一个非数字
var usrName = "andy";
console.log(isNaN(userName)); // true ，"andy"是一个非数字
```



#### 2.3 字符串型

字符串型可以是引号中的任意文本，其语法为 **双引号 ""** 和 **单引号''**

```javascript
var strMsg = "我爱北京天安门~"; // 使用双引号表示字符串
var strMsg2 = '我爱吃猪蹄~'; // 使用单引号表示字符串
// 常见错误
var strMsg3 = 我爱大肘子; // 报错，没使用引号，会被认为是js代码，但js没有这些语法
```

因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更**推荐使用单引号**。



##### 1. 字符串引号嵌套

JS 可以用**单引号嵌套双引号** ，或者用**双引号嵌套单引号** (**外双内单，外单内双**)

```javascript
var strMsg = '我是"高帅富"程序猿'; // 可以用''包含""
var strMsg2 = "我是'高帅富'程序猿"; // 也可以用"" 包含'' // 常见错误
var badQuotes = 'What on earth?"; // 报错，不能 单双引号搭配
```



##### 2.  字符串转义

类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 

转义符都是 \ 开头的，常用的转义符及其说明如下：

| 转义符 | 解释说明                    |
| ------ | --------------------------- |
| \n     | 换行符，n 是 newline 的意思 |
| \\\\   | 斜杠 \                      |
| \\'    | '单引号                     |
| \\"    | "双引号                     |
| \t     | tab 缩进                    |
| \b     | 空格，b 是 blank 的意思     |

![image-20211123234052658](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123234052658.png)

酷热难耐，火辣的太阳底下，我挺拔的身姿，成为了最为独特的风景。我审视四周，这里，是我的舞台，我就 是天地间的王者。这一刻，我豪气冲天，终于大喊一声："收破烂啦～"



##### 3. 字符串长度

字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符 串的长度。

```javascript
var strMsg = "我是帅气多金的程序猿！";
alert(strMsg.length); // 显示 11
```



##### 4. 字符串拼接

* 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 
* 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串

```javascript
//1.1 字符串 "相加" 
alert('hello' + ' ' + 'world'); // hello world
//1.2 数值字符串 "相加" 
alert('100' + '100'); // 100100
//1.3 数值字符串 + 数值
alert('11' + 12); // 1112
```

**\+ 号总结口诀：数值相加 ，字符相连**



##### 5. 字符串拼接加强

```javascript
console.log('pink老师' + 18);			// 只要有字符就会相连
var age = 18;
// console.log('pink老师age岁啦'); 		// 这样不行哦
console.log('pink老师' + age); 		// pink老师18
console.log('pink老师' + age + '岁啦'); // pink老师18岁啦
```

* 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值 
* 变量是不能添加引号的，因为加引号的变量会变成字符串 
* 如果变量两侧都有字符串拼接，口诀“**引引加加** ”，删掉数字，变量写加中间



![image-20211123234615632](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123234615632.png)

![image-20211123234645979](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123234645979.png)

![image-20211123234716150](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123234716150.png)

**案例代码**

```javascript
// 弹出一个输入框（prompt)，让用户输入年龄（用户输入）
// 把用户输入的值用变量保存起来,把刚才输入的年龄与所要输出的字符串拼接 （程序内部处理）
// 使用alert语句弹出警示框（输出结果）
var age = prompt('请输入您的年龄');
var str = '您今年已经' + age + '岁了';
alert(str);
```





#### 2.4 布尔型 Boolean

布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 

布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0



```javascript
console.log(true + 1); // 2
console.log(false + 1); // 1
```



#### 2.5 Undefined 和 Null

一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）

```javascript
var variable;
console.log(variable); // undefined
console.log('你好' + variable); // 你好undefined
console.log(11 + variable); // NaN
console.log(true + variable); // NaN
```

一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)

```javascript
var vari = null;
console.log('你好' + vari); // 你好null
console.log(11 + vari); // 11
console.log(true + vari); // 1
```





### 3. 获取变量数据类型

#### 3.1 获取检测变量的数据类型

typeof 可用来获取检测变量的数据类型

```javascript
var num = 18;
console.log(typeof num) // 结果 number 
```

不同类型的返回值

| 类型      | 例               | 结果        |
| --------- | ---------------- | ----------- |
| String    | typeof "小白"    | "String"    |
| Number    | typeof 18        | "number"    |
| Boolean   | typeof true      | "boolean"   |
| Undefined | typeof undefined | "undefined" |
| Null      | typeof null      | "object"    |



#### 3.2 字面量

字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 

* 数字字面量：8, 9, 10 
* 字符串字面量：'黑马程序员', "大前端" 
* 布尔字面量：true，false





### 4. 数据类型转换

#### 4.1 什么是数据类型转换

使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变 量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。

我们通常会实现3种方式的转换： 

* 转换为字符串类型 
* 转换为数字型 
* 转换为布尔



#### 4.2 转换为字符串

| 方式                    | 说明                         | 案例                                     |
| ----------------------- | ---------------------------- | ---------------------------------------- |
| toString()              | 转换成字符串                 | var num = 1; alert(num.toString());      |
| String                  | 转换成字符串                 | var num = 1; alert(String(num));         |
| **加号（+）拼接字符串** | 和字符串拼接的结果都是字符串 | var num = 1; alert(num + "我是字符串")； |

* toString() 和 String() 使用方式不一样。 
* 三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换



#### 4.3  转换为数字型（重点）

| 方式                    | 说明                         | 案例                |
| ----------------------- | ---------------------------- | ------------------- |
| parseInt(string) 函数   | 将string类型转成整数数值型   | parseInt('78')      |
| pardeFloat(string) 函数 | 将string类型转成浮点数值类型 | parseFloat('78.21') |
| Number() 强制转换函数   | 将string类型转换为数值型     | Number('12')        |
| js 隐式转换（ - * / ）  | 利用算术运算隐式转换为数值型 | '12' -0             |

* 注意 **parseInt** 和 **parseFloat** 单词的大小写，这2个是重点 
* 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型



##### 案例1：计算年龄

此案例要求在页面中弹出一个输入框，我们输入出生年份后，能计算出我们的年龄。

![image-20211204212131820](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212131820.png)

**案例分析**

① 弹出一个输入框（prompt)，让用户输入出生年份 （用户输入）

② 把用户输入的值用变量保存起来，然后用今年的年份减去变量值，结果就是现在的年龄 （程序内部处理）

③ 弹出警示框（alert) ， 把计算的结果输出 （输出结果）

**代码实现**

```javascript
// 1. 弹出输入框，输入出生年份，并存储在变量中
var year = prompt('请输入您的出生年份：'); // 用户输入
// 2. 用今年减去刚才输入的年份 
var result = 2019 - year; // 程序内部处理
// 3. 弹出提示框 
alert('您的年龄是:' + result + '岁'); // 输出结果
```



##### 案例2：简单加法器

计算两个数的值， 用户输入第一个值后，继续弹出第二个输入框并输入第二个值，最后通过弹出窗口显示出两次输入值相加的结果。

![image-20211204212404833](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212404833.png)

**案例分析**

① 先弹出第一个输入框，提示用户输入第一个值  保存起来

② 再弹出第二个框，提示用户输入第二个值 保存起来

③ 把这两个值相加，并将结果赋给新的变量（注意数据类型转换） 

④ 弹出警示框（alert) ， 把计算的结果输出 （输出结果）

**代码实现**

```javascript
// 1. 先弹出第一个输入框，提示用户输入第一个值
 var num1 = prompt('请输入第一个值：');
// 2. 再弹出第二个框，提示用户输入第二个值
var num2 = prompt('请输入第二个值：');
// 3. 将输入的值转换为数字型后，把这两个值相加，并将结果赋给新的变量 var result = parseFloat(num1) + parseFloat(num2);
// 4. 弹出结果
alert('结果是:' + result);
```



#### 4.4 转换为布尔型

| 方式          | 说明               | 案例            |
| ------------- | ------------------ | --------------- |
| Boolean()函数 | 其他类型转成布尔值 | Boolean("true") |

* 代表**空、否定**的值会被转换为 false ，如 ''、0、NaN、null、undefined 
* 其余值都会被转换为 true

```javascript
console.log(Boolean('')); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean('小白')); // true
console.log(Boolean(12)); // true
```





***

## 扩展阅读

### 1. 解释型语言和编译型语言

#### 1. 概述

计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行 程序。程序语言翻译成机器语言的工具，被称为翻译器。

![image-20211204212525483](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212525483.png)

* 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 
* 编译器是在代码执行之前进行编译，生成中间代码文件 
* 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)



#### 2. 执行过程

![image-20211204212557411](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212557411.png)

类似于请客吃饭：

* 编译语言：首先把所有菜做好，才能上桌吃饭

* 解释语言：好比吃火锅，边吃边涮，同时进行





### 2. 标识符、关键字、保留字

#### 1. 标识符

标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。

**标识符不能是关键字或保留字。**



#### 2. 关键字

关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、 instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。



#### 3. 保留字

保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能 使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、 fimal、float、goto、implements、import、int、interface、long、mative、package、 private、protected、public、short、static、super、synchronized、throws、transient、 volatile 等。

**注意**：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错 误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。





***

## JavaScript 运算符

### 1. 运算符

运算符（operator）也被称为**操作符**，是用于实现赋值、比较和执行算数运算等功能的符号。

JavaScript中常用的运算符有：

*  算数运算符
*  递增和递减运算符
*  比较运算符
*  逻辑运算符
*  赋值运算符



###  2. 算术运算符

#### 2.1 算术运算符概述

概念：算术运算使用的符号，用于执行两个变量或值的算术运算。

| 运算符 | 描述           | 案例                     |
| ------ | -------------- | ------------------------ |
| +      | 加             | 10 + 20 = 30             |
| -      | 减             | 10 - 20 = -10            |
| *      | 乘             | 10 * 20 = 200            |
| /      | 除             | 10 / 20 = 0.5            |
| %      | 取余数（取模） | 返回除法的余数 9 % 2 = 1 |



#### 2.2 浮点数的精度问题

浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。

```javascript
var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004
console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001
```

所以：**不要直接判断两个浮点数是否相等** !



#### 2.3 提问

1. 我们怎么判断 一个数能够被整除呢？

**它的余数是0 就说明这个数能被整除， 这就是 %  取余运算符的主要用途**

2. 请问 1 + 2  *  3 结果是？

**结果是7 ，注意算术运算符优先级的，先乘除，后加减，有小括号先算小括号里面的**



#### 2.4 表达式和返回值

表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合

简单理解：是由数字、运算符、变量等组成的式子

**表达式最终都会有一个结果，返回给我们，我们成为返回值**





### 3. 递增和递减运算符

#### 3.1 递增和递减运算符概述

如果需要反复给数字变量添加或减去1，可以使用**递增（++）**和**递减（ -- ）**运算符来完成。

在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。**放在变量前面**时，我们可以称为**前置递增（递减）运算符**，**放在变量后面**时，我们可以称为**后置递增（递减）运算符**。

注意：**递增和递减运算符必须和变量配合使用**。 



#### 3.2 递增运算符

##### 1. 前置递增运算符

**++num** 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。

使用口诀：先自加，后返回值

```javascript
var  num = 10;
alert(++num + 10);   // 21
```



##### 2. 后置递增运算符

**num++** 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。

使用口诀：**先返回原值，后自加** 

```javascript
var  num = 10;
alert(10 + num++);  // 20  返回结果后，num 的值为11
```



##### 3. 巩固练习

```javascript
var a = 10;
++a;
var b = ++a + 2;
console.log(b);

var c = 10;
c++;
var d = c++ + 2;
console.log(d);

var e = 10;
var f = e++ + ++e;
console.log(f);
```





#### 3.3 前置递增和后置递增小结

* 前置递增和后置递增运算符可以简化代码的编写，让变量的值 + 1  比以前写法更简单

* 单独使用时，运行结果相同

* 与其他代码联用时，执行结果会不同 

* 后置：先原值运算，后自加（先人后己） 

* 前置：先自加，后运算（先已后人）

* 开发时，大多使用后置递增/减，并且代码独占一行，例如：num++; 或者 num--;





### 4. 比较运算符

#### 4.1 比较运算符概述

概念：比较运算符（关系运算符）是**两个数据进行比较时所使用的运算符**，比较运算后，会**返回一个布尔值**（true / false）作为比较运算的结果。

| 运算符名称 | 说明                                   | 案例        | 结果  |
| ---------- | -------------------------------------- | ----------- | ----- |
| <          | 小于号                                 | 1 < 2       | true  |
| >          | 大于号                                 | 1 > 2       | false |
| >=         | 大于等于号（大于或者等于）             | 2 >= 2      | true  |
| <=         | 小于等于号（小于或者等于）             | 3 <= 2      | false |
| ==         | 判等号（会转型）                       | 37 == 37    | true  |
| !=         | 不等号                                 | 37 != 37    | false |
| ===  !==   | 全等（全不等）  要求值和数据类型都一致 | 37 === '37' | false |



#### 4.2 等号（=）小结

| 符号 | 作用 | 用法                                   |
| ---- | ---- | -------------------------------------- |
| =    | 赋值 | 把右边的值给左边                       |
| ==   | 判断 | 判断两边值是否相等（注意此时有隐式转换 |
| ===  | 全等 | 判断两边的值和数据类型是否完全相同     |

```javascript
console.log(18 == '18');  //true
console.log(18 === '18');  //false
```

```javascript
var num1 = 10;
var num2 = 100;
var res1 = num1 > num2;   
var res2 = num1 == 11;   
var res3 = num1 != num2; 
```





### 5. 逻辑运算符

#### 5.1 逻辑运算符概述

概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断

| 逻辑运算符 | 说明                     | 案例            |
| ---------- | ------------------------ | --------------- |
| &&         | “逻辑与”，简称 ”与“ and  | true && false   |
| \|\|       | ”逻辑或“， 简称 ”或“ or  | true \|\| false |
| ！         | ”逻辑非“， 简称 ”非“ not | ! true          |



#### 5.2 逻辑与&&

两边都是 true才返回 true，否则返回 false

![image-20211204212850478](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212850478.png)



#### 5.3 逻辑或||

两边都为 false 才返回 false，否则都为true

![image-20211204212836734](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204212836734.png)



#### 5.4 逻辑非！

逻辑非（**!**）也叫作**取反符**，用来取一个布尔值相反的值，如 true 的相反值是 false

```javascript
var isOk = !true; 
console.log(isOk); // false
```



#### 练习

```javascript
var num = 7;
var str = "我爱你~中国~";
console.log(num > 5 && str.length >= num);

console.log(num < 5 && str.length >= num);

console.log(!(num < 10));

console.log(!(num < 10 || str.length == num）);
            
```



#### 5.5 短路运算 （逻辑中断）

短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值；

##### 1.逻辑与

* 语法： 表达式1 && 表达式2

* 如果第一个表达式的值为真，则返回表达式2

* 如果第一个表达式的值为假，则返回表达式1

```javascript
console.log( 123 && 456 );        // 456
console.log( 0 && 456 );          // 0
console.log( 123 && 456&& 789 );  // 789
```



##### 2. 逻辑或

* 语法： 表达式1 || 表达式2

* 如果第一个表达式的值为真，则返回表达式1

* 如果第一个表达式的值为假，则返回表达式2

```javascript
console.log( 123 || 456 );         //  123
console.log( 0 ||  456 );          //  456
console.log( 123 || 456 || 789 );  //  123
```

```javascript
var num = 0;
console.log(123 || num++);
console.log(num);   
```





### 6. 赋值运算符

概念：用来把数据赋值给变量的运算符。

| 赋值运算符 | 说明                 | 案例                        |
| ---------- | -------------------- | --------------------------- |
| =          | 直接赋值             | var usrName = "我是值"；    |
| +=、-=     | 加、减一个数后再赋值 | var age = 10; age+=;  // 15 |
| *=、/=、%= | 乘、除、取模后再赋值 | var age = 2; age*=5;  // 10 |

```javascript
var age = 10;
age += 5;  // 相当于 age = age + 5;
age -= 5;  // 相当于 age = age - 5;
age *= 10; // 相当于 age = age * 10;
```





### 7. 运算符优先级

| 优先级 | 运算符     | 顺序               |
| ------ | ---------- | ------------------ |
| 1      | 小括号     | ()                 |
| 2      | 一元运算符 | ++ -- ！           |
| 3      | 算术运算符 | **先* / % 后 + -** |
| 4      | 关系运算符 | > >= < <=          |
| 5      | 相等运算符 | == != === !==      |
| 6      | 逻辑运算符 | **先 && 后 \|\|**  |
| 7      | 赋值运算符 | =                  |
| 8      | 逗号运算符 | ，                 |

* 一元运算符里面的逻辑非优先级很高

* 逻辑与比逻辑或优先级高



#### 练习1

 ```javascript
 console.log( 4 >= 6 || '人' != '阿凡达' && !(12 * 2 == 144) && true)
 var num = 10;
 console.log( 5 == num / 2 && (2 + 2 * num).toString() === ‘22’);
 
 ```

#### 练习2

```javascript
var a = 3 > 5 && 2 < 7 && 3 == 4; 
console.log(a);  

var b = 3 <= 4 || 3 > 1 || 3 != 2; 
console.log(b); 

var c = 2 === "2"; 
console.log(c);  

var d = !c || b && a ;
console.log(d);

```







***

## JavaScript 流程控制 - 分支

### 1. 流程控制

在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解： 流程控制就是来控制我们的代码按照什么结构顺序来执行

流程控制主要有三种结构，分别是**顺序结构、分支结构**和**循环结构**，这三种结构代表三种代码执行的顺序。

![image-20211124202528953](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124202528953.png)



### 2. 顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，**依次执行**，程序中大多数的代码都是这样执行的。

![image-20211124202633548](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124202633548.png)



### 3. 分支流程控制 if 语句

#### 3.1 分支结构

由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果

![image-20211124202742347](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124202742347.png)

JS 语言提供了两种分支结构语句

* if 语句

* switch 语句



#### 3.2 if 语句

##### 1. 语法结构

```javascript
// 条件成立执行代码，否则什么也不做
if (条件表达式) {
    // 条件成立执行的代码语句
}
```

语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。



##### 2. 执行流程

![image-20211124202958598](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124202958598.png)

![image-20211124203015361](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203015361.png)

![image-20211124203027686](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203027686.png)

```javascript
var usrAge = prompt('请输入您的年龄：');
if(usrAge >= 18){
    alert('您的年龄合法，欢迎来天际网吧享受学习的乐趣！');
}
```



#### 3.3 if else语句（双分支语句）

##### 1. 语法结构

```javascript
// 条件成立  执行 if 里面代码，否则执行else 里面的代码
if (条件表达式) {
    // [如果] 条件成立执行的代码
} else {
    // [否则] 执行的代码
}
```



##### 2. 执行流程

![image-20211124203207658](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203207658.png)





##### 3. 案例

![image-20211124203221757](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203221757.png)

![image-20211124203238995](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203238995.png)

**实现代码**

```javascript
  // 算法  如果你叫刘德华 恭喜您中奖了，否则没有中奖
  // 获得用户名
   var username = prompt("请输入您的姓名：");  
        if( username == "刘德华") {
            alert("恭喜发财");
        } else {
            alert("谢谢惠顾,欢迎下次再来");
    }
```





![image-20211124203452476](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203452476.png)

![image-20211124203503103](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203503103.png)

**实现代码**

```javascript
  // 算法  如果你叫刘德华 恭喜您中奖了，否则没有中奖
  // 获得用户名
   var username = prompt("请输入您的姓名：");  
        if( username == "刘德华") {
            alert("恭喜发财");
        } else {
            alert("谢谢惠顾,欢迎下次再来");
    }
```



#### 3.4 if else if 语句（多分支语句）

##### 1. 语法结构

```javascript
// 适合于检查多重条件。
if (条件表达式1) {
    语句1；
} else if (条件表达式2)  {
    语句2；
} else if (条件表达式3)  {
   语句3；
 ....
} else {
    // 上述条件都不成立执行此处代码
}
```



##### 2. 执行流程

![image-20211124203824360](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203824360.png)

##### 3. 案例

![image-20211124203852176](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203852176.png)

![image-20211124203908985](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124203908985.png)

**实现代码**

```javascript
var score = prompt('请您输入分数:');
if (score >= 90) {
alert('宝贝，你是我的骄傲');
} else if (score >= 80) {
alert('宝贝，你已经很出色了');
} else if (score >= 70) {
alert('你要继续加油喽');
} else if (score >= 60) {
alert('孩子，你很危险');
} else {
alert('熊孩子，我不想和你说话，我只想用鞭子和你说话');
}
```





### 4. 三元表达式

三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式

#### 1. 语法结构

```javascript
表达式1 ? 表达式2 : 表达式3;
```

#### 2. 执行思路

* 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值

* 简单理解： 就类似于 if else （双分支） 的简写

#### 3. 案例

![image-20211124204244715](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124204244715.png)

![image-20211124204301980](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124204301980.png)

**实现代码**

```javascript
  
var time = prompt('请您输入一个 0 ~ 59 之间的一个数字');
// 三元表达式 表达式 ？ 表达式1 ：表达式2 
var result = time < 10 ? '0' + time : time; // 把返回值赋值给一个变量
alert(result);
```





### 5. 分支流程控制 switch 语句

#### 5.1 语法结构

switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。

```javascript
switch( 表达式 ){ 
    case value1:
        // 表达式 等于 value1 时要执行的代码
        break;
    case value2:
        // 表达式 等于 value2 时要执行的代码
        break;
    default:
        // 表达式 不等于任何一个 value 时要执行的代码
}
```

* switch ：开关 转换 ， case ：小例子  选项

* 关键字 switch 后面**括号内**可以是表达式或值， 通常是一个**变量**

* 关键字 **case** , 后跟一个选项的表达式或值，**后面跟一个冒号**

* switch 表达式的值会与结构中的 case 的值做比较 

* 如果存在匹配**全等**(===) ，则与该 case 关联的代码块会被执行，并在**遇到 break 时停止**，整个 switch 语句代码执行结束

* 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码

**注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。**



##### 案例

![image-20211124204822392](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124204822392.png)

![image-20211124204835188](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124204835188.png)

**实现代码**

```javascript
var fruit = prompt('请您输入查询的水果:');
switch (fruit) {
case '苹果':
alert('苹果的价格是 3.5/斤');
break;
case '榴莲':
alert('榴莲的价格是 35/斤');
break;
default:
alert('没有此水果');
}
```



#### 5.2 **switch** **语句和** **if** **else if** **语句的区别**

1. 一般情况下，它们两个语句可以相互替换

2. switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)

3. switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。

4. 当分支比较少时，if… else语句的执行效率比 switch语句高。

5. 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。 



#### 5.3 练习

​	① 1. 判断时间阶段。 比如 用户输入12点 弹出 中午好 用户输入 18点 弹出傍晚好 用户输入 23点 弹出深夜好

​	② 2. 比较两个数的最大值  （用户依次输入2个值，最后弹出最大的那个值）

​	③ 3. 用户输入一个数，来判断是奇数还是偶数

​	④ 4. 根据用户输入的数值（数字1 到 数字 7），返回星期几

​	⑤ 5. 接收班长口袋里的钱数？若大于等于2000，请大家吃西餐。若小于2000，大于等于1500，请大家吃快餐。若小于1500，大于等于1000，请大家喝饮料。若小于1000，大于等于500，请大家吃棒棒糖。否则提醒班长下次把钱带够

​	⑥ 6. 分数转换,给一个分数，判定等级。大于等于90 A，大于等于80小于90 B，大于等于70小于80 C ，大于等于60小于70 D，小于60 E

​	⑦ 7. 预习下 循环控制 for 循环







***

## JavaScript 流程控制 - 循环

### 1. 循环

#### 1.1 循环的目的

* 在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句



#### 1.2 JS 中的循环

在Js 中，主要有三种类型的循环语句：

* for 循环

* while 循环

* do...while 循环





### 2. for循环

在程序中，一组被重复执行的语句被称之为**循环体**，能否继续重复执行，取决于循环的**终止条件**。由循环体及循环的终止条件组成的语句，被称之为**循环语句**

#### 2.1 语法结构

 for 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：

```javascript
for(初始化变量; 条件表达式; 操作表达式 ){
    //循环体
}
```

* **初始化变量**：通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。

* **条件表达式**：用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。

* **操作表达式**：每次循环的最后都要执行的表达式。通常被用于更新或者递增计数器变量。当然，递减变量也是可以的。



##### 执行过程：

1. 初始化变量，**初始化操作在整个 for 循环只会执行一次**。

2. 执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。

3. 执行操作表达式，此时第一轮结束。

4. 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。

5. 继续执行操作表达式，第二轮结束。

6. 后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。



##### 断点调试：

断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。

**断点调试可以帮我们观察程序的运行过程**

浏览器中按 F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点

Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。

F11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。

代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。

今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。



#### 2.2 **for** 循环重复相同的代码

for循环可以重复相同的代码 ，比如我们要输出10句“媳妇我错了”

```javascript
//  基本写法
for(var i = 1; i <= 10; i++){
    console.log('媳妇我错了~');
}
// 用户输入次数
var num = prompt('请输入次数:')；
for ( var i = 1 ; i <= num; i++) {
    console.log('媳妇我错了~');
} 
```



#### 2.3 for 循环重复不相同的代码

for 循环还可以重复不同的代码，这主要是因为使用了计数器 ，计数器在每次循环过程中都会有变化。

例如，求输出一个人1到100岁：

```javascript
//  基本写法
for (var i = 1; i <= 100; i++) {
      console.log('这个人今年' + i + '岁了');
}
```

```javascript

// for 里面是可以添加其他语句的 
for (var i = 1; i <= 100; i++) {
 if (i == 1) {
    console.log('这个人今年1岁了， 它出生了');
 } else if (i == 100) {
    console.log('这个人今年100岁了，它死了');
  } else {
       console.log('这个人今年' + i + '岁了');
  }
}
```

for 循环因为有了计数器的存在，我们还可以重复的执行某些操作，比如做一些算术运算。



##### 案例

![image-20211124210620508](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124210620508.png)

**实现代码**

```javascript
var sum = 0;
for(var i = 1;i <= 100; i++){
        sumNum += i;
}
console.log('1-100之间整数的和 = ' + sum);
```



![image-20211124210732093](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124210732093.png)



![image-20211124210754544](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124210754544.png)

![image-20211124212531158](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124212531158.png)

**实现代码**

```javascript
var num = prompt('请输入班级总的人数:'); // num 班级总的人数
var sum = 0; // 总成绩
var average = 0; // 平均成绩
for (var i = 1; i <= num; i++) {
     var score = prompt('请输入第' + i + '个学生的成绩');
     sum = sum + parseFloat(score);         
}
average = sum / num;
alert('班级总的成绩是：' + sum);
alert('班级总的平均成绩是：' + average);
```



##### 一行打印五个星星

![image-20211124212716387](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124212716387.png)

我们采取追加字符串的方式，这样可以打印到控制台上。

```javascript
var star = '';
for (var i = 1; i <= 5; i++) {
     star += '☆'
 }
console.log(star);
```



##### 思考

![image-20211124212812767](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124212812767.png)



### 3. 双重 for 循环

#### 3.1 双重 for循环概述

很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。

![image-20211124212812767](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124212812767.png)

**循环嵌套**是指**在一个循环语句中再定义一个循环语句的语法结构**，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为**双重for循环**。



#### 3.2 双重 for 循环语法

```javascript
for (外循环的初始; 外循环的条件; 外循环的操作表达式) {
    for (内循环的初始; 内循环的条件; 内循环的操作表达式) {  
       需执行的代码;
   }
}
```

* 内层循环可以看做外层循环的语句

* 内层循环执行的顺序也要遵循 for 循环的执行顺序 

* 外层循环执行一次，内层循环要执行全部次数

![image-20211124213405676](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124213405676.png)

核心： 

1. 内层循环负责一行打印五个星星

2. 外层循环负责打印五行



**代码实现**

```javascript
var star = '';
for (var j = 1; j <= 5; j++) {
    for (var i = 1; i <= 5; i++) {
      star += '☆'
    }
    // 每次满 5个星星 就 加一次换行
    star += '\n'
}
console.log(star);
```



##### 案例

![image-20211124213557960](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124213557960.png)

**代码实现**

```javascript
var row = prompt('请输入您打印几行星星:');
var col = prompt('请输入您打印几列星星:');
var str = '';
for (var i = 1; i <= row; i++) {
   for (j = 1; j <= col; j++) {
       str += '☆';
   }
   str += '\n';
}
 console.log(str);
```



![image-20211124213719387](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124213719387.png)

![image-20211124213730688](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124213730688.png)

**代码实现**

```javascript
var row = prompt('请输入您打印几行星星:');
var col = prompt('请输入您打印几列星星:');
var str = '';
for (var i = 1; i <= row; i++) {
   for (j = i; j <= col; j++) {
       str += '☆';
   }
   str += '\n';
}
 console.log(str);
```



##### 思考

![image-20211124213958441](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124213958441.png)

![image-20211124214018530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124214018530.png)

![image-20211124214034885](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124214034885.png)

```javascript
var str = ''
for (var i = 1; i <= 9; i++) { //  外层for控制 行数  9行
    for (var j = 1; j <= i; j++) { // j 控制列数    列数和行数是一样的  j <= i  
        str += j + " × " + i + " = " + i * j + '\t';
    }
    str += '\n';
}
console.log(str);
```





#### 3.3 for 循环小结

* for 循环可以重复执行某些相同代码

* for 循环可以重复执行些许不同的代码，因为我们有计数器

* for 循环可以重复执行某些操作，比如算术运算符加法操作

* 随着需求增加，双重for循环可以做更多、更好看的效果

* 双重 for 循环，外层循环一次，内层 for 循环全部执行

* for 循环是循环条件和数字直接相关的循环

* 分析要比写代码更重要

* 一些核心算法想不到，但是要学会，分析它执行过程

* 举一反三，自己经常总结，做一些相似的案例







### 4. while 循环

while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。

while语句的语法结构如下：

```javascript
while (条件表达式) {
    // 循环体代码 
}
```

#### 执行思路

​	① 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码

​	② 执行循环体代码

​	③ 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束



**注意**

​	① 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环

​	② while 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如判断用户名和密码



![image-20211124220315781](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124220315781.png)

![image-20211124220330507](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124220330507.png)

![image-20211124220355117](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124220355117.png)





### 5. do while 循环

do... while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。

do... while 语句的语法结构如下：

```javascript
do {
    // 循环体代码 - 条件表达式为 true 时重复执行循环体代码
} while(条件表达式);
```

##### 执行思路

① 先执行一次循环体代码 

② 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码

**注意：先再执行循环体，再判断，我们会发现 do…while 循环语句至少会执行一次循环体代码**



![image-20211124220616163](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124220616163.png)

![image-20211124220628155](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124220628155.png)

**代码实现**

```javascript
do {
  var love = prompt('你爱我吗？');
} while (love != '我爱你')
alert('登录成功');
```



#### 循环小结

* JS 中循环有 for 、while 、 do while 

* 三个循环很多情况下都可以相互替代使用

* 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用 for

* while 和 do…while 可以做更复杂的判断条件，比 for 循环灵活一些 

* while 和 do…while 执行顺序不一样，while 先判断后执行，do…while 先执行一次，再判断执行

* while 和 do…while 执行次数不一样，do…while 至少会执行一次循环体， 而 while 可能一次也不执行

* 实际工作中，我们更常用for 循环语句，它写法更简洁直观， 所以这个要重点学习





### 6. continue break

#### 6.1 continue 关键字

continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。

例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下：

```javascript
 for (var i = 1; i <= 5; i++) {
     if (i == 3) {
         console.log('这个包子有虫子，扔掉');
         continue; // 跳出本次循环，跳出的是第3次循环 
      }
      console.log('我正在吃第' + i + '个包子呢');
 }
```



#### 6.2 break 关键字

**break** **关键字用于**立即**跳出整个循环**（循环结束）。

例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下：

```javascript
for (var i = 1; i <= 5; i++) {
   if (i == 3) {
       break; // 直接退出整个for 循环，跳到整个for下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
 }
```







***

## JavaScript 命名规范以及语法格式

- 为了约定大家的代码风格，所以在社区中诞生了一些比较规范的风格规范：
  + JavaScript Standard Style
    + 网址：<https://standardjs.com/>
  + Airbnb JavaScript Style
    + 

### 1. 标识符命名规范

* 变量、函数的命名必须要有意义

* 变量的名称一般用名词 

* 函数的名称一般用动词 



### 2. 操作符规范

```javascript
// 操作符的左右两侧各保留一个空格
for (var i = 1; i <= 5; i++) {
   if (i == 3) {
       break; // 直接退出整个 for 循环，跳到整个for循环下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
}
```



### 单行注释规范

```javascript
for (var i = 1; i <= 5; i++) {
   if (i == 3) {
       break; // 单行注释前面注意有个空格
   }
   console.log('我正在吃第' + i + '个包子呢');
}
```



### 4. 其他规范

![image-20211124222709555](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124222709555.png)





### 5. 练习

```javascript
1. 求1-100之间所有数的总和与平均值
2. 求1-100之间所有偶数的和
3. 求100以内7的倍数的总和
4. 使用for 循环打印矩形，要求每次只能输出一个☆
      ☆☆☆☆☆
      ☆☆☆☆☆
      ☆☆☆☆☆
      ☆☆☆☆☆
5. 使用for循环打印三角形
      ☆
      ☆☆
      ☆☆☆
      ☆☆☆☆
      ☆☆☆☆☆
```

```javascript
6.使用for循环打印99乘法表
7.接收用户输入的用户名和密码，若用户名为 “admin” ,密码为 “123456” ,则提示用户登录成功!  否则，让用户一直输入。
8.求整数1～100的累加值，但要求跳过所有个位为3的数【用continue实现】。
```

![image-20211124222833117](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124222833117.png)







***

## JavaScript 数组

### 1. 数组的概念

问：之前学习的数据类型，只能存储一个值。如果我们想存储班级中所有学生的姓名，那么该如何存储呢？

答：可以使用数组(Array)。数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。

问：什么是数组呢？

答：数组是指**一组数据的集合**，其中的每个数据被称作**元素**，在数组中可以**存放任意类型的元素**。数组是一种将**一组数据存储在单个变量名**下的优雅方式。

```javascript
// 普通变量一次只能存储一个值
var  num = 10; 
// 数组一次可以存储多个值
var arr = [1,2,3,4,5];
```



### 2. 创建数组

#### 2.1 数组的创建方式

JS 中创建数组有两种方式：

* 利用 new 创建数组 

* 利用数组字面量创建数组



#### 2.2 利用 new 创建数组

```javascript
var 数组名 = new Array() ；
var arr = new Array();   // 创建一个新的空数组
```

* 这种方式暂且了解，等学完对象再看

* 注意 Array () ，A 要大写  



#### 2.3 利用数组字面量创建数组

```javascript
//1. 使用数组字面量方式创建空的数组
var  数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var  数组名 = ['小白','小黑','大黄','瑞奇'];
```

* 数组的字面量是方括号 [ ] 

* 声明数组并赋值称为数组的初始化

* 这种字面量方式也是我们以后**最多使用的方式** 



#### 2.4 数组元素的类型

数组中可以存放**任意类型**的数据，例如字符串，数字，布尔值等。

```javascript
var arrStus = ['小白',12,true,28.9];
```



#### 2.5 反思

1. 数组的作用是什么？

2. 创建数组我们有哪两种方式？ 哪一种我们最常用？

3. 什么是数组元素？ 数组里面类型有限制吗？ 





### 3. 获取数组元素

#### 3.1 数组的索引

**索引 (下标) ：**用来访问数组元素的序号（数组下标从 0 开始）。

![image-20211124223737169](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124223737169.png)

数组可以通过**索引**来访问、设置、修改对应的数组元素，我们可以通过**“数组名[索引]**”的形式来获取数组中的元素。

这里的**访问**就是获取得到的意思

```javascript
// 定义数组
var arrStus = [1,2,3];
// 获取数组中的第2个元素
alert(arrStus[1]);    
```



#### 案例

![image-20211124223905720](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124223905720.png)





### 4. 遍历数组

问：数组中的每一项我们怎么取出来？

答：可以通过“数组名[索引号]”的方式一项项的取出来。

```javascript
var arr = ['red','green', 'blue'];
console.log(arr[0]) // red
console.log(arr[1]) // green
console.log(arr[2]) // blue
```

问：怎么把数组里面的元素全部取出来？

**规律**

从代码中我们可以发现，从数组中取出每一个元素时，代码是重复的，有所不一样的是**索引**值在递增

**答案就是 循环**

**遍历**： 就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名）。

我们可以通过 **for** 循环索引遍历数组中的每一项

```javascript
var arr = ['red','green', 'blue'];
for(var i = 0; i < arr.length; i++){
    console.log(arrStus[i]);
}
```



#### 4.1 数组的长度

使用“数组名.length”可以访问数组元素的数量（数组长度）。 

```javascript
var arrStus = [1,2,3];
alert(arrStus.length);  // 3
```

**注意：** 

① 此处数组的长度是**数组元素的个数** ，不要和数组的**索引号**混淆。

② 当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化。



#### 案例

![image-20211124224304288](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224304288.png)

```javascript
var arr = ["关羽","张飞","马超","赵云","黄忠","刘备","姜维"]; 
// 遍历  从第一个到最后一个
for(var i = 0; i < arr.length; i++ )  { 
   console.log( arr[i] );
} 
```



#### 反思

![image-20211124224419300](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224419300.png)





![image-20211124224430095](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224430095.png)

![image-20211124224441866](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224441866.png)

**代码实现**

```javascript
var arr = [2, 6, 1, 7, 4];
var sum = 0;
var average = 0;
for (var i = 0; i < arr.length; i++) {
    sum += arr[i];
}
average = sum / arr.length;
console.log('这组数的和是：' + sum);
console.log('这组数的平均值是：' + average);
```



![image-20211124224549220](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224549220.png)

![image-20211124224559994](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224559994.png)

**代码实现**

```javascript
var arrNum = [2,6,1,77,52,25,7];
var maxNum = arrNum[0]; // 用来保存最大元素,默认最大值是数组中的第一个元素
// 从0 开始循环数组里的每个元素
for(var i = 0;i< arrNum.length; i++){
    // 如果数组里当前循环的元素大于 maxNum，则保存这个元素和下标
    if(arrNum[i] > maxNum){
        maxNum = arrNum[i]; // 保存数值到变量 maxNum
    }
}
```



![image-20211124224648537](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224648537.png)

![image-20211124224658742](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224658742.png)

**代码实现**

```javascript
var arr = ['red', 'green', 'blue', 'pink'];
var str = '';
for (var i = 0; i < arr.length; i++) {
    str += arr[i];
}
console.log(str);
```



![image-20211124224809473](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224809473.png)

![image-20211124224821882](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124224821882.png)

**代码实现**

```javascript
var arr = ['red', 'green', 'blue', 'pink'];
var str = '';
var separator = '|'
for (var i = 0; i < arr.length; i++) {
   str += arr[i] + separator;
}
console.log(str);
```





### 5. 数组中新增元素

#### 5.1 通过修改 length 长度新增数组元素

* 可以通过修改 length 长度来实现数组扩容的目的

* length 属性是可读写的

```javascript
var arr = ['red', 'green', 'blue', 'pink'];
arr.length = 7;
console.log(arr);
console.log(arr[4]);
console.log(arr[5]);
console.log(arr[6]);
```

其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined。

![image-20211124225132290](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225132290.png)



#### 5.2 通过修改数组索引新增数组元素

* 可以通过修改数组索引的方式追加数组元素

* 不能直接给数组名赋值，否则会覆盖掉以前的数据

```javascript
var arr = ['red', 'green', 'blue', 'pink'];
arr[4] = 'hotpink';
console.log(arr);
```

这种方式也是我们最常用的一种方式。



#### 案例

![image-20211124225309858](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225309858.png)

![image-20211124225334833](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225334833.png)

**代码实现**

```javascript
var arr = [];
for (var i = 0; i < 10; i++) {
    arr[i] = i + 1;
}
console.log(arr);
```



![image-20211124225432196](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225432196.png)

![image-20211124225444766](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225444766.png)

**代码实现1**

```javn
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
var newArr = [];
// 定义一个变量 用来计算 新数组的索引号
var j = 0;
for (var i = 0; i < arr.length; i++) {
    if (arr[i] >= 10) {
        // 给新数组
        newArr[j] = arr[i];
        // 索引号 不断自加
        j++;
    }
}
console.log(newArr);
```

**代码实现2**

```javascript
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
var newArr = [];
for (var i = 0; i < arr.length; i++) {
    if (arr[i] >= 10) {
        // 给新数组
        newArr[newArr.length] = arr[i];
    }
}
console.log(newArr);
```





### 6. 数组案例

![image-20211124225656093](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225656093.png)

![image-20211124225711690](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225711690.png)

**代码实现**

```javascript
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
var newArr = [];   // 空数组的默认的长度为 0 
// 定义一个变量 i 用来计算新数组的索引号
for (var i = 0; i < arr.length; i++) {
    // 找出大于 10 的数
    if (arr[i] != 0) {
        // 给新数组
        // 每次存入一个值，newArr长度都会 +1  
        newArr[newArr.length] = arr[i];
    }
}
console.log(newArr);
```



![image-20211124225832338](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225832338.png)

![image-20211124225843969](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124225843969.png)



![image-20211124230644973](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124230644973.png)

```javascript
// 利用第三个变量
var num1 = 10;
var num2 = 20;
var temp = num1;
num1 = num2;
num2 = temp;
console.log(num1, num2);
```

![image-20211124230743753](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124230743753.png)

![image-20211124230759785](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124230759785.png)

**代码实现**

```javascript
   var arr = [5, 4, 3, 2, 1];
        for (var i = 0; i < arr.length - 1; i++) {
            for (var j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    var temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
  console.log(arr);
```







***

## JavaScript 函数

### 1. 函数的概念

在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 **JS 中的函数**。

**函数：**就是封装了一段**可被重复调用执行的代码块**。通过此代码块可以实现大量代码的重复使用。 



### 2. 函数的使用

函数在使用时分为两步：声明函数和调用函数。

#### 2.1 声明函数

```javascript
// 声明函数
function 函数名() {
    //函数体代码
}
```

* function 是声明函数的关键字,必须小写

* 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum  



#### 2.2 调用函数

```javascript
// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
```

* 调用的时候千万**不要忘记添加小括号**

* 口诀：函数不调用，自己不执行。

**注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。**



#### 2.3 函数的封装

* 函数的封装是把一个或者多个功能通过**函数的方式封装起来**，对外只提供一个简单的函数接口

* 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） 

![image-20211124231442107](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211124231442107.png)

#### 案例：利用函数计算1-100之间的累加和

```javascript
/* 
   计算1-100之间值的函数
*/
// 声明函数
function getSum(){
  var sumNum = 0;// 准备一个变量，保存数字和
  for (var i = 1; i <= 100; i++) {
    sumNum += i;// 把每个数值 都累加 到变量中
  }
  alert(sumNum);
}
// 调用函数
getSum();

```

#### 反思

1. 函数是做什么的（作用）？

2. 声明函数用什么关键词？

3. 如何调用函数？ 

4. 封装是什么意思？ 





### 3. 函数的参数

#### 3.1 形参和实参

在**声明函数时**，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在**调用该函数时**，同样也需要传递相应的参数，这些参数被称为**实参**。

| 参数 | 说明                                                     |
| ---- | -------------------------------------------------------- |
| 形参 | 形式上的参数，函数定义的时候传递的参数，当前不知道是什么 |
| 实参 | 实际上的参数，函数调用时传递的参数， 实参是传递给形参的  |

**参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

```javascript
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
```



#### 案例：利用函数求任意两个数的和

```javascript
function getSum(num1, num2) {
    console.log(num1 + num2);
}
getSum(1, 3); // 4
getSum(6, 5); // 11
```



#### 3.2 函数参数的传递过程

```javascript
// 声明函数
function getSum(num1, num2) {
    console.log(num1 + num2);
}
// 调用函数
getSum(1, 3); // 4
getSum(6, 5); // 11
```

1. 调用的时候实参值是传递给形参的

2. 形参简单理解为：**不用声明的变**

3. 实参和形参的多个参数之间用逗号（,）分隔



#### 3.3 函数形参和实参个数不匹配问题

| 参数个数             | 说明                                   |
| -------------------- | -------------------------------------- |
| 实参个数等于形参个数 | 输出正确结果                           |
| 实参个数多于形参个数 | 只取到形参的个数                       |
| 实参个数少于形参个数 | 多的形参个数定义为undefined，结果为NaN |

```javascript

function sum(num1, num2) {
    console.log(num1 + num2);
}
sum(100, 200);             // 形参和实参个数相等，输出正确结果
sum(100, 400, 500, 700);   // 实参个数多于形参，只取到形参的个数
sum(200);                  // 实参个数少于形参，多的形参定义为undefined，结果为NaN
```

**注意：**在JavaScript中，形参的默认值是**undefined**。



#### 3.4 小结

* 函数可以带参数也可以不带参数

* 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined

* 调用函数的时候，函数名括号里面的是实参

* 多个参数中间用逗号分隔

* 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配





### 4. 函数的返回值

#### 4.1 return 语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

return 语句的语法格式如下：

```javascript
// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
```

* 在使用 return 语句时，函数会停止执行，并返回指定的值

* 如果函数**没有 return** ，返回的值是 **undefined**



#### 案例

**案例1：利用函数求任意两个数的最大值**

```javascript
function getMax(num1, num2) {
    return num1 > num2 ? num1 : num2;
}
console.log(getMax(1, 2));
console.log(getMax(11, 2));
```



![image-20211125082718034](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125082718034.png)

```javascript
//定义一个获取数组中最大数的函数
function getMaxFromArr(numArray){
    var maxNum = 0;
    for(var i =0;i < numArray.length;i++){
        if(numArray[i] > maxNum){
            maxNum = numArray[i];
        }
    }
    return maxNum;
}
var arrNum = [5,2,99,101,67,77];
var maxN = getMaxFromArr(arrNum); // 这个实参是个数组
alert('最大值为：'+ maxN);
```





#### 4.2 return 终止函数

return 语句之后的代码不被执行。

```javascript
function add(num1，num2){
    //函数体
    return num1 + num2; // 注意：return 后的代码不执行
    alert('我不会被执行，因为前面有 return');
}
var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);          // 27
```





#### 4.3 return 的返回值

**return** **只能返回一个值**。如果用逗号隔开多个值，以最后一个为准。

```javascript
function add(num1，num2){
    //函数体
    return num1，num2;
}
var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);          // 6
```



![image-20211125082948875](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125082948875.png)

```javascript
var a = parseFloat(prompt('请输入第一个数'));
var b = parseFloat(prompt('请输入第二个数'));
function count(a, b) {
    var arr = [a + b, a - b, a * b, a / b];
    return arr;
}
var result = count(a, b);
console.log(result);
```





#### 4.4 函数没有 return 返回 undefined

函数都是有返回值的

1.如果有return 则返回 return 后面的值

2.如果没有return 则返回 undefined 



#### 4.5 break ,continue ,return 的区别

* break ：结束当前的循环体（如 for、while）

* continue ：跳出本次循环，继续执行下次循环（如 for、while）

* return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码



#### 4.6. 通过榨汁机看透函数

![image-20211125204927774](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125204927774.png)



**作业**

①  写一个函数，用户输入任意两个数字的任意算术运算（简单的计算器小功能），并能弹出运算后的结果。

②  写一个函数，用户输入任意两个数字的最大值，并能出弹运算后的结果。

③  写一个函数，用户输入任意三个不同数字的最大值，并能弹出运算后的结果。

④  写一个函数，用户输入一个数判断是否是素数，并返弹出回值(又叫质数，只能被1和自身整数的数)



### 5. arguments的使用

当我们不确定有多少个参数传递的时候，可以用 **arguments** 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个**内置对象**。所有函数都内置了一个 arguments 对象，arguments 对象中**存储了传递的所有实参**。

**arguments展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：

* 具有 length 属性

* 按索引方式储存数据

* 不具有数组的 push , pop 等方法



**案例：利用函数求任意个数的最大值**

```javascript
function maxValue() {
      var max = arguments[0];
      for (var i = 0; i < arguments.length; i++) {
         if (max < arguments[i]) {
                    max = arguments[i];
         }
      }
      return max;
}
 console.log(maxValue(2, 4, 5, 9));
 console.log(maxValue(12, 4, 9));
```





### 6. 函数案例

**案例1：利用函数封装方式，翻转任意一个数组**

```javascript
function reverse(arr) {
var newArr = [];
for (var i = arr.length - 1; i >= 0; i--) {
newArr[newArr.length] = arr[i];
}
return newArr;
}
var arr1 = reverse([1, 3, 4, 6, 9]);
console.log(arr1);
```



**案例2：利用函数封装方式，对数组排序 -- 冒泡排序**

```javascript
function sort(arr) {
for (var i = 0; i < arr.length - 1; i++) {
for (var j = 0; j < arr.length - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
var temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
}
}
}
return arr;
}
```



**案例3：判断闰年**

要求：输入一个年份，判断是否是闰年（闰年：能被4整除并且不能被100整数，或者能被400整除）

```javascript
function isRun(year) {
     var flag = false;
     if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        flag = true;
     }
    return flag;
}
console.log(isRun(2010));
console.log(isRun(2012));
```



#### 函数可以调用另外一个函数

因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。

![image-20211125210155403](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125210155403.png)

```javascript
function fn1() {
  console.log(111);
  fn2();
  console.log('fn1');
}
function fn2() {
  console.log(222);
  console.log('fn2');
}
fn1();
```



**案例4：用户输入年份，输出当前年份2月份的天数**

如果是闰年，则2月份是 29天， 如果是平年，则2月份是 28天





### 7. 函数的两种声明方式

#### 1. 自定义函数方式（命名函数）

利用函数关键字 function 自定义函数方式。

```javascript
// 声明定义方式
function fn() {...}
// 调用  
fn();  
```

* 因为有名字，所以也被称为**命名函数**

* 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面



#### 2. 函数表达式方式（匿名函数）

利用函数表达式方式的写法如下： 

```javascript
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

* 因为函数没有名字，所以也被称为**匿名函数**

* 这个fn 里面存储的是一个函数 

* 函数表达式方式原理跟声明变量方式是一致的

* 函数调用的代码必须写到函数体后面



**作业**

①  写一个函数，实现反转任意数组。

②  写一个函数，实现对数字数组的排序。



![image-20211125210620615](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125210620615.png)







***

## JavaScript 作用域

### 1. 作用域

#### 1.1 作用域概述

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的**可用性的代码范围**就是这个名字的**作用域**。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

JavaScript（es6前）中的作用域有两种：

* 全局作用域

* 局部作用域（函数作用域）



#### 1.2 全局作用域

作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。



#### 1.3 局部作用域（函数作用域）

作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。



#### 1.4 JS 没有块级作用域

* 块作用域由 { } 包括。

* 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：

```javascript
if(true){
  int num = 123;
  system.out.print(num);  // 123
}
system.out.print(num);    // 报错
```

Js中没有块级作用域（在ES6之前）。

```javascript
if(true){
  var num = 123;
  console.log(123); //123
}
console.log(123);   //123
```





### 2. 变量的作用域

#### 2.1 变量作用域的分类

在JavaScript中，根据作用域的不同，变量可以分为两种：

* 全局变量

* 局部变量



#### 2.2 全局变量

在全局作用域下声明的变量叫做**全局变量（在函数外部定义的变量）**。

* 全局变量在代码的任何位置都可以使用

* 在全局作用域下 var 声明的变量 是全局变量

* 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）



在局部作用域下声明的变量叫做**局部变量（在函数内部定义的变量）**

* 局部变量只能在该函数**内部**使用

* 在函数内部 var 声明的变量是局部变量

* 函数的**形参**实际上就是局部变量



#### 2.3 全局变量和局部变量的区别

* 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存

* 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间





### 3. 作用域链

* 只要是代码，就至少有一个作用域

* 写在函数内部的局部作用域

* 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域

* 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链



**案例1：结果是几？**

```javascript
function f1() {
    var num = 123;
    function f2() {
        console.log( num );
    }
    f2();
}
var num = 456;
f1();
```

![image-20211125211936275](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125211936275.png)

作用域链：采取**就近原则**的方式来查找变量最终的值。



**案例2：结果是几？**

```javascript
var a = 1;
function fn1() {
    var a = 2;
    var b = '22';
    fn2();
    function fn2() {
        var a = 3;
        fn3();
        function fn3() {
            var a = 4;
            console.log(a); //a的值 ?
            console.log(b); //b的值 ?
        }
    }
}
fn1();
```







***

## JavaScript 预解析

### 1. 预解析

1 问：

```javascript
console.log(num);  // 结果是多少？
```

2 问：

```javascript
console.log(num);  // 结果是多少？
var num = 10;   ？
```

3 问：

```javascript
fn();
function fn() {
    console.log('打印');
}
```

4 问：

```javascript
fn();
var  fn = function() {
    console.log('想不到吧');
}
```

JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。

* **预解析：**在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。

* **代码执行：** 从上到下执行JS语句。

预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道为什么在变量声明之前访问变量的值是 undefined，为什么在函数声明之前就可以调用函数。



#### 2.1 变量预解析（变量提升）

预解析也叫做变量、函数提升。

**变量提升：** 变量的声明会被提升到**当前作用域**的最上面，变量的赋值不会提升。

```javascript
console.log(num);  // 结果是多少？
var num = 10;      // undefined
```



#### 2.2 函数预解析（函数提升）

**函数提升：** 函数的声明会被提升到**当前作用域**的最上面，但是不会调用函数。

```javascript
fn();
function fn() {
    console.log('打印');
}
```



#### 2.3 解决函数表达式声明调用问题

```javascript
fn();
var  fn = function() {
    console.log('想不到吧');
}
```



**练习：结果是几？**

```javascript
// 练习
alert(a);
var a = 1;
alert(a)
function a(){
    return false;
}
```





### 3. 预解析案例

**案例1：结果是几？**

```javascript
// 案例1
var num = 10;
fun();
function fun() {
  console.log(num);
  var num = 20;
}
```

**案例2：结果是几？**

```javascript
// 案例2
var num = 10;
function fn(){
    console.log(num);
    var num = 20;
    console.log(num);
} 
fn();
```

**案例3：结果是几？**

```javascript
// 案例3
var a = 18;
f1();
function f1() {
  var b = 9;
  console.log(a);
  console.log(b);
  var a = '123';
}
```

**案例4：结果是几？**

```javascript
// 案例4
f1();
console.log(c);
console.log(b);
console.log(a);
function f1() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
```







***

## JavaScript 对象

### 1. 对象

#### 1.1 什么是对象？

现实生活中：万物皆对象，对象是**一个具体的事物**，看得见摸得着的实物。例如，一本书、一辆汽车、一个人可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。

```javascript
  明星    周星驰(星爷)  女朋友    迪丽热巴     班主任    咱们班班主任 

  苹果    这个苹果      手机    pink老师的小米手机     游戏    刺激战场 
```

在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由**属性**和**方法**组成的。

* 属性：事物的**特征，**在对象中用**属性**来表示（常用名词）

* 方法：事物的**行为，**在对象中用**方法**来表示（常用动词）

![image-20211125213426545](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125213426545.png)



#### 1.2 为什么需要对象

保存一个值时，可以使用**变量，**保存多个值（一组值）时，可以使用**数组。**如果要保存一个人的完整信息呢？

例如，将“张三疯”的个人的信息保存在数组中的方式为：

```javascript
var arr = [‘张三疯’, ‘男', 128,154];
```

JS 中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下：

```javascript
// 张三疯.姓名 =  ‘张三疯';
// 
// 张三疯.性别 = ‘男'; 
// 
// 张三疯.年龄 = 128; 
// 
// 张三疯.身高 = 154； 

person.name =  ‘张三疯';

person.sex = ‘男'; 

person.age = 128; 

person.height = 154； 

```





### 2. 创建对象的三种方式

在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：

* 利用字面量创建对象 

* 利用 new Object 创建对象 

* 利用构造函数创建对象 



#### 2.1 利用字面量创建对象

**对象字面量**：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。

{ } 里面采取**键值对**的形式表示 

* 键：相当于属性名

* 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）

```javascript
var star = {
    name : 'pink',
    age : 18,
    sex : '男',
    sayHi : function(){
        alert('大家好啊~');
    }
};
```



##### 对象的调用

* 对象里面的属性调用 : **对象.属性名** ，这个小点 . 就理解为“ **的** **”** 

* 对象里面属性的另一种调用方式 : **对象[‘属性名’]**，注意方括号里面的属性**必须加引号**，我们后面会用   

* 对象里面的方法调用：**对象.方法名()** **，**注意这个方法名字后面**一定加括号** 

```javascript
console.log(star.name)     // 调用名字属性
console.log(star['name'])  // 调用名字属性
star.sayHi();              // 调用 sayHi 方法,注意，一定不要忘记带后面的括号
```



**练习：请按照要求写出对象**

请用对象字面量的形式创建一个名字为可可的狗对象。  

具体信息如下：

* 姓名：可可 

* 类型(type)：阿拉斯加犬

* 年龄：5岁，

* 颜色：棕红色。 

* 技能：汪汪汪(bark) ，演电影 (showFilm)

![image-20211125214118915](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125214118915.png)



#### 变量、属性、函数、方法总结

* 变量：单独声明赋值，单独存在

* 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征

* 函数：单独存在的，通过“函数名()”的方式就可以调用

* 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。



#### 2.2 利用new Object创建对象

跟我们前面学的 new Array() 原理一致

```javascript
var andy = new Obect();
andy.name = 'pink';
andy.age = 18;
andy.sex = '男';
andy.sayHi = function(){
    alert('大家好啊~');
}
```

* Object() ：第一个字母大写  

* new Object() ：需要 new 关键字

* 使用的格式：对象.属性 = 值;   

**练习：请按照要求写出对象**

请用new Object 形式创建一个鸣人对象。 

具体信息如下： 

* 姓名：鸣人 

* 性别：男 

* 年龄：19岁 

* 技能（skill）：影分身术



#### 2.3 利用构造函数创建对象

**构造函数 ：**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

在 js 中，使用构造函数要时要注意以下两点：

* 构造函数用于创建某一类对象，其**首字母要大写**

* 构造函数要和 **new 一起使用**才有意义

```javascript
function Person(name, age, sex) {
     this.name = name;
     this.age = age;
     this.sex = sex;
     this.sayHi = function() {
      alert('我的名字叫：' + this.name + '，年龄：' + this.age + '，性别：' + this.sex);
    }
}
var bigbai = new Person('大白', 100, '男');
var smallbai = new Person('小白', 21, '男');
console.log(bigbai.name);
console.log(smallbai.name);
```

**注意:**

1. 构造函数约定**首字母大写**。

2. 函数内的**属性和方法**前面需要添加 **this** ，表示当前对象的属性和方法。

3. 构造函数中**不需要 return** 返回结果。

4. 当我们创建对象的时候，**必须用 new** 来调用构造函数。



**练习：请按照要求创建对象**

利用构造函数创建两个英雄对象。函数中的公共部分包括：姓名属性(name)，类型属性（type），血量属性（blood）和攻击方式（attack）。

英雄对象的信息如下 ： 

* 廉颇  力量型  500血量  攻击 ：近战 

* 后羿  射手型  100血量  攻击： 远程

![image-20211125214837708](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125214837708.png)



#### 2.4 构造函数和对象

* 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 

* 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 

![image-20211125214949212](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125214949212.png)

  



### 3. new关键字

![image-20211125215133436](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211125215133436.png)





### 4.遍历对象属性

**for...in 语句**用于对数组或者对象的属性进行循环操作。

其语法如下：

```javascript
for (变量 in 对象名字) {
    // 在此执行代码
}
```

语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。

```javascript
for (var k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
```





### 小结

1. 对象可以让代码结构更清晰

2. 对象复杂数据类型object。

3. 本质：对象就是一组无序的相关属性和方法的集合。

4. 构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果。

5. 对象实例特指一个事物，比如这个苹果、正在给你们讲课的pink老师等。

6. for...in 语句用于对对象的属性进行循环操作。



#### 练习

1.创建一个电脑对象，该对象要有颜色、重量、品牌、型号，可以看电影、听音乐、打游戏和敲代码。

2.创建一个按钮对象，该对象中需要包含宽，高，背景颜色和点击行为。

3.创建一个车的对象，该对象要有重量、颜色、牌子，可以载人、拉货和耕田。



①  写一个函数，实现反转任意数组。

②  写一个函数，实现对数字数组的排序。

![image-20211126083559342](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211126083559342.png)







***

## JavaScript 内置对象

### 1. 内置对象

* JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象

* 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于我们JS 独有的， 我们JS API 讲解

*  内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）

* 内置对象最大的优点就是帮助我们快速开发

* JavaScript 提供了多个内置对象：Math、 Date 、Array、String等





### 2. 查文档

#### 2.1 MDN

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。

Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。

MDN:  https://developer.mozilla.org/zh-CN/



#### 2.2 如何学习对象的方法

1. 查阅该方法的功能

2. 查看里面参数的意义和类型

3. 查看返回值的意义和类型

4. 通过 demo 进行测试





### 3. Math 对象

#### 3.1 Math 概述

Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。

```javascript
Math.PI		 // 圆周率
Math.floor() 	 // 向下取整
Math.ceil()            // 向上取整
Math.round()           // 四舍五入版 就近取整   注意 -3.5   结果是  -3 
Math.abs()		 // 绝对值
Math.max()/Math.min()	 // 求最大和最小值 
```

注意：上面的**方法必须带括号**



**案例：封装自己的数学对象**

利用对象封装自己的数学对象 里面有 PI 最大值和最小值





#### 3.2 随机数方法 rando()

random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 

得到一个两数之间的随机整数，包括两个数在内

```javascript
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min; 
}
```

return Math.floor(Math.random() * (max - min + 1)) + min



**案例：猜数字游戏**

程序随机生成一个 1~ 10 之间的数字，并让用户输入一个数字，

1. 如果大于该数字，就提示，数字大了，继续猜；

2. 如果小于该数字，就提示数字小了，继续猜；

3. 如果等于该数字，就提示猜对了， 结束程序。

**案例分析**

① 随机生成一个1~10 的整数 我们需要用到 Math.random() 方法。

② 需要一直猜到正确为止，所以一直循环。

③ 用while 循环合适更简单。

④ 核心算法：使用 if else if 多分支语句来判断大于、小于、等于。





### 4. 日期对象

#### 4.1 Date 概述

* Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用

* Date 实例用来处理日期和时间





#### 4.2 Data()方法的使用

##### 1. 获取当前时间必须实例化

```javascript
var now = new Date();
console.log(now);
```

##### 2. Date() 构造函数的参数

如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成new Date('2019-5-1') 或者 new Date('2019/5/1')

* **如果Date()不写参数，就返回当前时间**

* **如果Date()里面写参数，就返回括号里面输入的时间**





#### 4.3 日期格式化

我们想要 2019-8-8 8:8:8 格式的日期，要怎么办？ 

需要获取日期指定的部分，所以我们要手动的得到这种格式。  

| 方法名        | 说明                       | 代码               |
| ------------- | -------------------------- | ------------------ |
| getFullYear() | 获取当年                   | dObj.getFullYear() |
| getMonth()    | 获取当月（0-11）           | dObj.getMonth()    |
| getDate()     | 获取当天日期               | dObj.getDate()     |
| getDay()      | 获取星期几（周日0 到周六） | dObj.getDay()      |
| getHours()    | 获取当前小时               | dObj.getHours()    |
| getMinutes()  | 获取当前分钟               | dObj.getMinutes()  |
| getSeconds()  | 获取当前秒钟               | dObj.getSeconds()  |



**案例：输出当前日期**

请写出这个格式的日期：2019年8月8日 星期四 



**案例：输出当前事件**

写一个函数，格式化日期对象，成为 HH:mm:ss 的形式  比如 00:10:45





#### 4.4 获取日期的总的毫秒形式

Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数

[为什么计算机起始时间从1970年开始](https://www.zhihu.com/question/27005396/answer/34868386)?

我们经常利用总的毫秒数来计算时间，因为它更精确

```javascript
// 实例化Date对象
var date= new Date();
// 1. 用于获取对象的原始值
console.log(date.valueOf())	
console.log(date.getTime())	
// 2. 简单写可以这么做
var now = + new Date();			
// 3. HTML5中提供的方法，有兼容性问题
var now = Date.now();
```



**案例：倒计效果**

![image-20211126223619336](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211126223619336.png)

**案例分析**

① 核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时 ，但是不能拿着时分秒相减，比如 05 分减去25分，结果会是负数的。

② 用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数。

③ 把剩余时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒）

​	 转换公式如下：

* d = parseInt(总秒数/ 60/60 /24);   // 计算天数

* h = parseInt(总秒数/ 60/60 %24)  //  计算小时

* m = parseInt(总秒数 /60 %60 );   //  计算分数

* s = parseInt(总秒数%60);        //  计算当前秒数





### 5.数组对象

#### 5.1 数组对象的创建

创建数组对象的两种方式

* 字面量方式

* new Array()





#### 5.2 检测是否为数组

* instanceof 运算符，可以判断一个对象是否属于某种类型

* Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法  

```javascript
var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
console.log(Array.isArray(arr));   // true
console.log(Array.isArray(obj));   // false
```





#### 5.3 添加删除数组元素的方法

| 方法名            | 说明                                                      | 返回值               |
| ----------------- | --------------------------------------------------------- | -------------------- |
| push(参数1...)    | 末尾添加或多个元素，注意会修改原数组                      | 并返回新的长度       |
| pop()             | 删除数组最后一个元素，把数组长度减 1 ，无参数、修改原数组 | 返回他删除的元素的值 |
| unshift(参数1...) | 向数组的开头添加一个或更多元素，注意会修改原数组          | 并返回新的长度       |
| shift()           | 删除数组的第一个元素，数组长度减 1 ，无参数、修改元数组   | 并返回第一个元素的值 |



##### 案例：筛选数组

有一个包含工资的数组[1500, 1200, 2000, 2100, 1800]，要求把数组中工资超过2000的删除，剩余的放到新数组里面

```javascript
var arr = [1500, 1200, 2000, 2100, 1800];
var newArr = [];
for (var i = 0; i < arr.length; i++) {
    if (arr[i] < 2000) {
        newArr.push(arr[i]);
    }
}
console.log(newArr);
```





#### 5.4 数组排序

| 方法名    | 说明                         | 是否修改原数组                        |
| --------- | ---------------------------- | ------------------------------------- |
| reverse() | 颠倒数组中元素的顺序，无参数 | 该方法会改变原来的数组    返回新数组  |
| sort()    | 对数组的元素进行排序         | 该方法会改变原来的而数组   返回新数组 |

```javascript
var arr = [1, 64, 9, 6];
arr.sort(function(a, b) {
    return b - a;      // 降a序
    // return a - b;   // 升序
});
console.log(arr);
```





#### 5.5 数组索引方法

| 方法名        | 说明                         | 返回值                                   |
| ------------- | ---------------------------- | ---------------------------------------- |
| indexOf()     | 数组查找给定元素的第一个索引 | 如果存在返回索引号，如果不存在则返回-1。 |
| lastIndexOf() | 在数组中的最后一个的索引     | 如果存在返回索引号，如果不存在则返回-1。 |





##### 案例：数组去重（重点案例）

有一个数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]，要求去除数组中重复的元素。



**案例分析**

① 目标：把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放到新数组中去重。

② 核心算法：我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过，我们就添加，否则不添加。

③ 我们怎么知道该元素没有存在？ 利用 新数组.indexOf(数组元素)  如果返回时 -1 就说明 新数组里面没有改元素 



旧数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]

新数组  [ ]





#### 5.6 数组转换为字符串

| 方法名         | 说明                                                         | 返回值         |
| -------------- | ------------------------------------------------------------ | -------------- |
| toString()     | 把数组转换成字符串，逗号分隔每一项                           | 返回一个字符串 |
| join('分隔符') | 方法用于把数组中的所有元素转换为一个字符串，用指定分隔符隔开 | 返回一个字符串 |





#### 5.7 其余数组对象方法

| 方法名   | 说明                                     | 返回值                                         |
| -------- | ---------------------------------------- | ---------------------------------------------- |
| concat() | 链接两个或多个数组，不影响原数组         | 返回一个新数组                                 |
| slice()  | 数组截取slice(begin,end)                 | 返回被截取项目的新数组                         |
| splice() | 数组删除splice(第几个开始，要删除的个数) | 返回被删除项目的新数组，注意：这个会影响原数组 |

slice() 和 splice() 目的基本相同，建议同学们重点看下 splice()







### 6. 字符串对象 

#### 6.1 基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。

**基本包装类型**就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

```javascript
// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
```

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：

```javascript
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
```





#### 6.2 字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```javascript
var str = 'abc';
str = 'hello';
// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = '';
for (var i = 0; i < 100000; i++) {
    str += i;
}
console.log(str); // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```





#### 6.3 根据字符返回位置

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| indexOf('要查找的字符'，开始的位置) | 返回指定内容在元字符中的位置，如果找不到就返回-1，开始的位置是index 索引号 |
| lastIndexOf()                       | 从后往前找，只找第一个匹配的                                 |





#### 案例：返回字符串位置

查找字符串"abcoefoxyozzopp"中所有o出现的位置以及次数



**思路**

① 核心算法：先查找第一个o出现的位置

② 然后 只要indexOf 返回的结果不是 -1 就继续往后查找

③ 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 





#### 6.4 根据位置返回字符（重点）

| 方法名            | 说明                                         | 使用                        |
| ----------------- | -------------------------------------------- | --------------------------- |
| charAt(index)     | 返回指定位置处的字符（index 字符串的索引号） | str.charAt(0)               |
| charCodeAt(index) | 返回指定位置处的ASCII码（index索引号）       | str.charCodeAt(0)           |
| str[index]        | 获取指定位置字符                             | HTML5，IE8+支持和charAt等效 |



##### 案例：返回字符位置

判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。

① 核心算法：利用 charAt(） 遍历这个字符串

② 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1

③ 遍历对象，得到最大值和该字符 

判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。

对象 o { }





#### 6.5 字符串操作方法（重点）

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| concat(str1,str2,str3...) | concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用 |
| substr(start,length)      | 从start位置开始（索引号），length 取的个数    重点记住这个   |
| slice（start，end）       | 从start位置开始，截取到end位置，end取不到（他们俩都是索引号） |
| substring(start,end)      | 从start位置开始，截取到end位置，end取不到，基本和slice相同，但是不接受负值 |





#### 6.6 replace()方法

**replace()** 方法用于在字符串中用一些字符**替换**另一些字符。

其使用格式如下： 

```javascript
replace(被替换的字符串， 要替换为的字符串)；
```





#### 6.7 split()方法

**split()**方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。

例如下面代码： 

```javascript
var str = 'a,b,c,d';
console.log(str.split(','));   // 返回的是一个数组 [a, b, c, d]
```





#### 字符串对象其余方法

*  toUpperCase()  //转换大写

*  toLowerCase()  //转换小写





#### 练习

给定一个字符串，如：“abaasdffggghhjjkkgfddsssss3444343”，问题如下： 

1、 字符串的长度 

2、 取出指定位置的字符，如：0,3,5,9等 

3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 

4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 

5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串

6、 找出以上字符串中出现次数最多的字符和出现的次数 

7、 遍历字符串，并将遍历出的字符两头添加符号“@”







***

## JavaScript 简单数据类型于复杂数据类型

### 1. 简单类型与复杂类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。

* 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型

string ，number，boolean，undefined，null

* 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型

 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等





#### 2. 堆和栈

堆栈空间分配区别：

　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

**简单数据类型存放到栈里面**

　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

**复杂数据类型存放到堆里面**

![image-20211126234117164](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211126234117164.png)

**注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。**





### 3. 简单类型的内存分配

* 值类型（简单数据类型）： string ，number，boolean，undefined，null

* 值类型变量的数据直接存放在变量（栈空间）中

![image-20211127011856160](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127011856160.png)



### 4. 复杂类型的内存分配

* 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等

* 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中

![image-20211127014408329](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127014408329.png)



### 5. 简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```javascript
function fn(a) {
    a++;
    console.log(a); 
}
var x = 10;
fn(x);
console.log(x)；
```





### 6. 复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```javascript
function Person(name) {
    this.name = name;
}
function f1(x) { // x = p
    console.log(x.name); // 2. 这个输出什么 ?    
    x.name = "张学友";
    console.log(x.name); // 3. 这个输出什么 ?    
}
var p = new Person("刘德华");
console.log(p.name);    // 1. 这个输出什么 ?   
f1(p);
console.log(p.name);    // 4. 这个输出什么 ?  
```







***

## DOM

### 1. DOM 简介

#### 1.1 什么是 DOM

文档对象模型（Document Object Model，简称 **DOM**），是 W3C 组织推荐的处理可扩展标记语言（HTML 或者XML）的标准**编程接口**。 

W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。



#### 1.2 DOM 树

![image-20211127124042965](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127124042965.png)

* 文档：一个页面就是一个文档，DOM 中使用 document 表示 
* 元素：页面中的所有标签都是元素，DOM 中使用 element 表示 
* 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示 

**DOM 把以上内容都看做是对象**





### 2. 获取元素

#### 2.1 如何获取页面元素

DOM在我们实际开发中主要用来操作元素。 

我们如何来获取页面中的元素呢?

获取页面中的元素可以使用以下几种方式: 

* 根据 ID 获取 
* 根据标签名获取
* 通过 HTML5 新增的方法获取 
* 特殊元素获



#### 2.2 根据 ID获取

使用 getElementById() 方法可以获取带有 ID 的元素对象。

```javascript
document.getElementById('id');
```

使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。



#### 2.3 根据标签名获取

使用 getElementsByTagName() 方法可以返回带有指定标签名的**对象的集合**。

```javascript
document.getElementsByTagName('标签名');
```

**注意：**

1. **因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。**

2. **得到元素对象是动态的**



#### 2.4 通过 HTML5 新增的方法获取

```javascript
1. document.getElementsByClassName(‘类名’)；// 根据类名返回元素对象集合
```

```javascript
2. document.querySelector('选择器'); // 根据指定选择器返回第一个元素对象
```

```javascript
3. document.querySelectorAll('选择器'); // 根据指定选择器返回
```

**注意：**

querySelector 和 querySelectorAll里面的选择器**需要加符号**,比如:document.querySelector('#nav');



#### 2.5 获取特殊元素（body，html）

##### 获取body元素

```javascript
1. doucumnet.body // 返回body元素对象
```

##### 获取html元素

```javascript
1. document.documentElement // 返回html元素对象
```







### 3. 事件基础

#### 3.1 事件概述

JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 

简单理解： 触发--- 响应机制。 

网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。





#### 3.2 事件三要素

1. 事件源 （谁）
2. 事件类型 （什么事件）
3. 事件处理程序 （做啥



##### 案例：点击弹出警示框

页面中有一个按钮，当鼠标点击按钮的时候，弹出“你好”警示框。

![image-20211127125310002](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127125310002.png)

**案例分析**

① 获取事件源（按钮） 

② 注册事件（绑定事件），使用 onclick 

③ 编写事件处理程序，写一个函数弹出 alert 警示



**代码实现**

```javascript
var btn = document.getElementById('btn');
btn.onclick = function() {
 alert('你好吗'); 
};
```





#### 3.3 执行事件的步骤

1. 获取事件源
2. 注册事件（绑定事件） 
3. 添加事件处理程序（采取函数赋值形式）



#### 3.4 常见的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |



#### 3.5 分析事件三要素

下拉菜单三要素

关闭广告三要素







### 4. 操作元素

JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内 容 、属性等。注意以下都是属性

#### 4.1 改变元素内容

```javascript
element.innerText
```

从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去

```javascript
element.innerHTML
```

起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行



#### 4.2 常用元素的属性操作

```javascript
1. innerText、innerHTML 改变元素内容
2. src、href
3. id、alt、title
```



##### 案例：分时显示不同图片，显示不同问候语

根据不同时间，页面显示不同图片，同时显示不同的问候语。 

如果上午时间打开页面，显示上午好，显示上午的图片。 

如果下午时间打开页面，显示下午好，显示下午的图片。 

如果晚上时间打开页面，显示晚上好，显示晚上的图片。



**案例分析**

① 根据系统不同时间来判断，所以需要用到日期内置对象 

② 利用多分支语句来设置不同的图片 

③ 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性

④ 需要一个div元素，显示不同问候语，修改元素内容即可





#### 4.3 表单元素的属性操作

```javascript
type、value、checked、selected、disabled
```



##### 案例：仿京东显示密码

点击按钮将密码框切换为文本框，并可以查看密码明文。

![image-20211127130826486](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127130826486.png)

**案例分析**

① 核心思路： 点击眼睛按钮，把密码框类型改为文本框就可以看见里面的密码 

② 一个按钮两个状态，点击一次，切换为文本框，继续点击一次切换为密码框 

③ 算法：利用一个flag变量，来判断flag的值，如果是1 就切换为文本框，flag 设置为0，如 果是0 就切换为密码框，flag设置为1



**实现代码**

```javascript
```





#### 4.4 样式属性操作

我们可以通过 JS 修改元素的大小、颜色、位置等样式。

```javascript
1. element.style 行内样式操作
2. element.className 类名样式操作
```

**注意：** 

1. **JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor** 
2. **JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高**



##### 案例：淘宝点击关闭二维码

当鼠标点击二维码关闭按钮的时候，则关闭整个二维码。

![image-20211127131435296](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127131435296.png)

**案例shi分析**

① 核心思路： 利用样式的显示和隐藏完成， display:none 隐藏元素 display:block 显示元素 

② 点击按钮，就让这个二维码盒子隐藏起来即



**代码实现**

```javascript
var btn = document.querySelector('.close-btn');
var box = document.querySelector('.box');
// 2.注册事件 程序处理
btn.onclick = function() {
box.style.display = 'none';
```



##### 案例：循环精灵图背景



![image-20211127131700549](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127131700549.png)

**案例分析**

① 首先精灵图图片排列有规律的 

② 核心思路： 利用for循环 修改精灵图片的 背景位置 background-position 

③ 剩下的就是考验你的数学功底了 

④ 让循环里面的 i 索引号 * 44 就是每个图片的y坐标

**代码实现**

```javascript
var lis = document.querySelectorAll('li');
for (var i = 0; i < lis.length; i++) {
// 让索引号 乘以 44 就是每个li 的背景y坐标 index就是我们的y坐标
var index = i * 44;
lis[i].style.backgroundPosition = '0 -' + index + 'px';
}
```





##### 案例：显示隐藏文本框内容

当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示。

![image-20211127131855631](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127131855631.png)

**案例分析**

① 首先表单需要2个新事件，获得焦点 onfocus 失去焦点 onblur  

② 如果获得焦点， 判断表单里面内容是否为默认文字，如果是默认文字，就清空表单内容 

③ 如果失去焦点， 判断表单内容是否为空，如果为空，则表单内容改为默认文字



注意： 

1. 如果样式修改较多，可以采取操作类名方式更改元素样式。
2. class因为是个保留字，因此使用className来操作元素类名属性 
3. className 会直接更改元素的类名，会覆盖原先的类名。





##### 案例：密码框格式提示错误信息

用户如果离开密码框，里面输入个数不是6~16，则提示错误信息，否则提示输入正确信息

![image-20211127132137260](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127132137260.png)

**案例分析**

① 首先判断的事件是表单失去焦点 onblur 

② 如果输入正确则提示正确的信息颜色为绿色小图标变化 

③ 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化 

④ 因为里面变化样式较多，我们采取className修改样式





#### 4.5 操作元素总结

操作元素是 DOM 核心内容

![image-20211127132325933](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127132325933.png)



##### 练习

1. 世纪佳缘 用户名 显示隐藏内容 
2. 京东关闭广告（直接隐藏即可） 
3. 新浪下拉菜单（微博即可） 
4. 开关灯案例（见素材）





#### 4.6 排他思想

![image-20211127132506492](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127132506492.png)

如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法： 

1. 所有元素全部清除样式（干掉其他人）
2. 给当前元素设置样式 （留下我自己） 
3.  注意顺序不能颠倒，首先干掉其他人，再设置自己



##### 案例：百度换肤

**案例分析**

① 这个案例练习的是给一组元素注册事件 

② 给4个小图片利用循环注册点击事件 

③ 当我们点击了这个图片，让我们页面背景改为当前的图片 

④ 核心算法： 把当前图片的src 路径取过来，给 body 做为背景即



**代码实现**

```javascript
// 1. 获取元素
var imgs = document.querySelector('.baidu').querySelectorAll('img');
// 2. 循环注册事件
for (var i = 0; i < imgs.length; i++) {
imgs[i].onclick = function() {
document.body.style.backgroundImage = 'url(' + this.src + ')';
}
}
```





##### 案例：表格隔行变色

![image-20211127132858422](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127132858422.png)



**案例分析**

① 用到新的鼠标事件 鼠标经过 onmouseover 鼠标离开 onmouseout 

② 核心思路：鼠标经过 tr 行，当前的行变背景颜色， 鼠标离开去掉当前的背景颜色 

③ 注意： 第一行（thead里面的行）不需要变换颜色，因此我们获取的是 tbody 里面的





##### 案例：表单全选取消全选案例

**业务需求：** 

1. 点击上面全选复选框，下面所有的复选框都选中（全选） 
2. 再次点击全选复选框，下面所有的复选框都不中选（取消全选） 
3. 如果下面复选框全部选中，上面全选按钮就自动选中 
4. 如果下面复选框有一个没有选中，上面全选按钮就不选中 
5. 所有复选框一开始默认都没选中状态

![image-20211127133039021](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127133039021.png)

**案例分析**

① **全选和取消全选做法**： 让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 

② **下面复选框需要全部选中， 上面全选才能选中**做法： 给下面所有复选框绑定点击事件，每次点击，都 要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。 

③ 可以设置一个变量，来控制全选是否选中





#### 4.7 自定义属性的操作

##### 1. 获取属性值

* element.属性 获取属性值。
* element.getAttribute('属性');

**区别：**

* element.属性 获取内置属性值（元素本身自带的属性） 
* element.getAttribute(‘属性’); 主要获得自定义的属性 （标准） 我们程序员自定义的属性





##### 2.设置属性值

* element.属性 = ‘值’ 设置内置属性值。 
* element.setAttribute('属性', '值');

**区别：**

* element.属性 设置内置属性值
* element.setAttribute(‘属性’); 主要设置自定义的属性 （标准）



##### 3. 移除属性

* element.removeAttribute('属性');



##### 案例：tab 栏切换（重点案例）

当鼠标点击上面相应的选项卡（tab），下面内容跟随变化

![image-20211127133749733](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127133749733.png)

**案例分析**

① Tab栏切换有2个大的模块 

② 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类 名的方式 

③ 下面的模块内容，会跟随上面的选项卡变化。所以下面模块变化写到点击事件里面。 

④ 规律：下面的模块显示内容和上面的选项卡一一对应，相匹配。 

⑤ 核心思路： 给上面的tab_list 里面的所有小li 添加自定义属性，属性值从0开始编号。 

⑥ 当我们点击tab_list 里面的某个小li，让tab_con 里面对应序号的 内容显示，其余隐藏（排他 思想）



 

#### 4.8 H5 自定义属性

**自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中**。 

自定义属性获取是通过getAttribute(‘属性’) 获取。 

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 

H5给我们新增了自定义属性：



##### 1. 设置 H5 自定义属性

H5规定自定义属性data-开头做为属性名并且赋值。 

**比如:** 

```javascript
<div data-index=“1”></div>
```

**或者使用 JS 设置 element.setAttribute(‘data-index’, 2)**



##### 2. 获取H5自定义属性

1. 兼容性获取 element.getAttribute(‘data-index’); 
2. H5新增 **element.dataset.index** 或者 element.dataset**[‘index’]** ie 11才开始支持





### 5. 节点操作

#### 5.1 为什么学节点操作

获取元素通常使用两种方式：

1. **利用 DOM 提供的方法获取元素**

* document.getElementById()  
* document.getElementsByTagName()
* document.querySelector 等 
* 逻辑性不强、繁琐



2. **利用节点层级关系获取元素**

* 利用父子兄节点关系获取元素 
* 逻辑性强， 但是兼容性稍差

这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单





#### 5.2 节点概述

网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 

HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。

![image-20211127134902735](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127134902735.png)

一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性

* 元素节点 nodeType 为 1 
* 属性节点 nodeType 为 2 
* 文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等） 

**我们在实际开发中，节点操作主要操作的是元素节点**





#### 5.3 节点层级

利用 DOM 树可以把节点划分为不同的层级关系，常见的是**父子兄层级关系**。

![image-20211127135047397](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127135047397.png)

##### 1. 父级节点

```javascript
node.parentNode 
```

* parentNode 属性可返回某节点的父节点，注意是最近的一个父节点 
* 如果指定的节点没有父节点则返回 null 



##### 2. 子节点

```javascript
1. parentNode.childNodes（标准） 
```

parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。 

**注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。** 

**如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNod**

```javascript
var ul = document. querySelector(‘ul’);
for(var i = 0; i < ul.childNodes.length;i++) {
if (ul.childNodes[i].nodeType == 1) {
 // ul.childNodes[i] 是元素节点
 console.log(ul.childNodes[i]);
}
}
```



```javascript
2. parentNode.children（非标准）
```

parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返 回 （**这个是我们重点掌握的**）。 

虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用



```javascript
3. parentNode.firstChild 
```

firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。



```javascript
 4. parentNode.lastChild 
```

lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。



```javascript
5. parentNode.firstElementChild
```

firstElementChild 返回第一个子元素节点，找不到则返回null。



```javascript
 6. parentNode.lastElementChild 
```

lastElementChild 返回最后一个子元素节点，找不到则返回null。 

**注意：5、6这两个方法有兼容性问题，IE9 以上才支持。**



实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？



**解决方案：** 

1. **如果想要第一个子元素节点，可以使用 parentNode.chilren[0]** 
2. **如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1]** 



##### 案例：下拉菜单

![image-20211127140037415](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127140037415.png)

**案例分析**

① 导航栏里面的li 都要有鼠标经过效果，所以需要循环注册鼠标事件 

② 核心原理： 当鼠标经过li 里面的 第二个孩子 ul 显示， 当鼠标离开，则ul 隐藏



**代码实现**

```javascript
var nav = document.querySelector('.nav');
var lis = nav.children; // 得到4个小li
for (var i = 0; i < lis.length; i++) {
lis[i].onmouseover = function() {
this.children[1].style.display = 'block';
}
lis[i].onmouseout = function() {
this.children[1].style.display = 'none';
}
}
```





##### 3. 兄弟节点

```javascript
1. node.nextSibling
```

nextSibling 返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。

```javascript
2. node.previousSibling 
```

previousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。

```javascript
3. node.nextElementSibling 
```

nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。

```javascript
 4. node.previousElementSibling 
```

previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。

**注意：这两个方法有兼容性问题， IE9 以上才支持**



**问：如何解决兼容性问题 ？**

答：自己封装一个兼容性的函数

```javascript
 function getNextElementSibling(element) {
 var el = element;
 while (el = el.nextSibling) {
 if (el.nodeType === 1) {
 return el;
 }
 }
 return null;
 } 
```





#### 5.4 创建节点

```javascript
 document.createElement('tagName')
```

document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在， 是根据我们的需求动态生成的，所以我们也称为**动态创建元素节点**。





##### 5.5 添加节点

```javascript
1. node.appendChild(child) 
```

node.appendChild() 方法将一个节点添加到指定父节点的子节点列表**末尾**。类似于 CSS 里面的 after 伪元素。

```javascript
 2. node.insertBefore(child, 指定元素)
```



node.insertBefore() 方法将一个节点添加到父节点的指定子节点**前面**。类似于 CSS 里面的 before  伪元素。

添加HTML内容与文本内容以前用的是innerHTML与innerText方法，

最近发现还有insertAdjacentHTML和 insertAdjacentText方法，

这两个方法更灵活，可以在指定的地方插入html内容和文本内容。

 

insertAdjacentText方法与 insertAdjacentHTML方法类似，只不过只能插入纯文本，参数相同

方法名称：insertHtml(where,el,html)

参数介绍：
where：插入位置。包括beforeBegin,beforeEnd,afterBegin,afterEnd。
el：用于参照插入位置的html元素对象
html：要插入的html代码


insertAdjacentHTML 方法：在指定的地方插入html标签语句

原型：insertAdajcentHTML(swhere,stext)

参数：

swhere: 指定插入html标签语句的地方，

stext:要插入的内容

有四种值可用：

1.     beforeBegin: 插入到标签开始前

2.     afterBegin:插入到标签开始标记之后

3.     beforeEnd:插入到标签结束标记前

4.     afterEnd:插入到标签结束标记后



##### 案例：简单版发布留言案例

**案例分析**

① 核心思路： 点击按钮之后，就动态创建一个li，添加到ul 里面。 

② 创建li 的同时，把文本域里面的值通过li.innerHTML 赋值给 li 

③ 如果想要新的留言后面显示就用 appendChild 如果想要前面显示就用insertBefore





#### 5.6 删除节点

```java
node.removeChild(child) 
```

node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点



##### 案例： 删除留言案例

**案例分析**

① 当我们把文本域里面的值赋值给li 的时候，多添加一个删除的链接 

② 需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的li 

③ 阻止链接跳转需要添加 javascript:void(0); 或者 javascript:



#### 5.7 复制节点（克隆节点）

```javascript
 node.cloneNode()
```

node.cloneNode() 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节

**注意：** 

1. 如果括号**参数为空或者为 false** ，则是**浅拷贝**，即只克隆复制节点本身，不克隆里面的子节点。 
2. 如果括号**参数为 tru**e ，则是**深度拷贝**，会复制节点本身以及里面所有的子节点。



##### 案例：动态生成表格

![image-20211127163753999](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127163753999.png)

**案例分析**

① 因为里面的学生数据都是动态的，我们需要js 动态生成。 这里我们模拟数据，自己定义好 数据。 数据我们采取对象形式存储。 

② 所有的数据都是放到tbody里面的行里面。 

③ 因为行很多，我们需要循环创建多个行（对应多少人） 

④ 每个行里面又有很多单元格（对应里面的数据），我们还继续使用循环创建多个单元格， 并且把数据存入里面（双重for循环） 

⑤ 最后一列单元格是删除，需要单独创建单元格。 

⑥ 最后添加删除操作，单击删除，可以删除当前行。





#### 5.8 三种动态创建元素区别

* document.write() 
* element.innerHTML 
* document.createElement()

**区别：**

1. document.write 是直接将内容写入页面的内容流，**但是文档流执行完毕，则它会导致页面全部重绘** 
2. innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 
3. innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 
4. createElement() 创建多个元素效率稍低一点点，但是结构更清晰

**总结：不同浏览器下，innerHTML 效率要比 creatElement 高**





### 6. DOM 重点核心

文档对象模型（Document Object Model，简称 **DOM**），是 W3C 组织推荐的处理可扩展标记语言 （HTML或者XML）的标准**编程接口**。 

W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 

1.  对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。 
2. 对于HTML，dom使得html形成一棵dom树. 包含 文档、元素、节点

![image-20211127164115617](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127164115617.png)

关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。



#### 6.1 创建

1. document.write 
2. innerHTML 
3. createElement



#### 6.2 增

1. appendChild 
2. insertBefore



#### 6.3 删

1. removeChild



#### 6.4 改

主要修改dom的元素属性，dom元素的内容、属性, 表单的值等

1. 修改元素属性： src、href、title等 
2. 修改普通元素内容： innerHTML 、innerText 
3. 修改表单元素： value、type、disabled等 
4. 修改元素样式： style、className



#### 6.5 查

主要获取查询dom的元素

1. DOM提供的API 方法： getElementById、getElementsByTagName 古老用法 不太推荐 
2. H5提供的新方法： querySelector、querySelectorAll 提倡 
3. 利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling) 提倡



#### 6.6 属性操作

主要针对于自定义属性。

1. setAttribute：设置dom的属性值 
2. getAttribute：得到dom的属性值 
3. removeAttribute移除属性



#### 6.7 事件操作

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| noclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |







***

## 事件高级

### 1. 注册事件（绑定事件）

#### 1.1 注册事件概述

给元素添加事件，称为**注册事件**或者**绑定事件**。 

注册事件有两种方式：**传统方式和方法监听注册方式**



##### 传统注册方式

* 利用 on 开头的事件 onclick 
* <button onclick="alert('hi~')"\></button/\>
* btn.onclick = function() {}  
*  特点： 注册事件的唯一性 
* 同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会覆盖前面注册的处理函数



#####  方法监听注册方式

* w3c 标准 推荐方式  addEventListener() 它是一个方法 
* IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替 
* 特点：同一个元素同一个事件可以注册多个监听器 
* 按注册顺序依次执行





#### 1.2 addEventListener 事件监听方式 

```javascript
eventTarget.addEventListener(type, listener[, useCapture]) 
```

eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。 

该方法接收三个参数： 

* **type**：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on 
* **listener**：事件处理函数，事件发生时，会调用该监听函数 
* **useCapture**：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习



#### 1.3 attachEvent 事件监听方式

```javascript
eventTarget.attachEvent(eventNameWithOn, callback)
```

eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触 发指定的事件时，指定的回调函数就会被执行。

该方法接收两个参数： 

* **eventNameWithOn**：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on 
* **callback**： 事件处理函数，当目标触发事件时回调函数被调用 注意：IE8 及早期版本支持

**注意：IE8 及早期版本支持**



#### 1.4 注册事件兼容性解决方案

```javascript
function addEventListener(element, eventName, fn) {
 // 判断当前浏览器是否支持 addEventListener 方法
 if (element.addEventListener) {
 element.addEventListener(eventName, fn); // 第三个参数 默认是false
 } else if (element.attachEvent) {
 element.attachEvent('on' + eventName, fn);
 } else {
 // 相当于 element.onclick = fn;
 element['on' + eventName] = fn;
 }
```

**兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器**





### 2. 删除事件

#### 2.1 删除事件的方式

##### 1. 传统注册方式

eventTarget.onclick = null;

##### 2. 方法监听注册方式

① eventTarget.removeEventListener(type, listener[, useCapture]); 

② eventTarget.detachEvent(eventNameWithOn, callback);





#### 2.2 删除事件兼容性解决方案

```javascript
function removeEventListener(element, eventName, fn) {
 // 判断当前浏览器是否支持 removeEventListener 方法
 if (element.removeEventListener) {
 element.removeEventListener(eventName, fn); // 第三个参数 默认是false
 } else if (element.detachEvent) {
 element.detachEvent('on' + eventName, fn);
 } else {
 element['on' + eventName] = null;
 }
```





### 3. DOM 事件流

**事件流**描述的是从页面中接收事件的顺序。 

**事件**发生时会在元素节点之间**按照特定的顺序传播**，这个**传播过程**即 **DOM 事件流**。 

比如我们给一个div 注册了点击事件：

DOM 事件流分为3个阶段： 

1. 捕获阶段 
2. 当前目标阶段 
3. 冒泡阶段

![image-20211127180845052](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127180845052.png)



* 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。 
* 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。



我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。

![image-20211127181012909](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127181012909.png)

#### 事件流注意事项

1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。 
2. onclick 和 attachEvent 只能得到冒泡阶段。 
3. addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。
4.  **实际开发中我们很少使用事件捕获，我们更关注事件冒泡。** 
5. **有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave** 
6. **事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。**





### 4. 事件对象

#### 4.1 什么是事件对象

```javascript
eventTarget.onclick = function(event) {} 
 eventTarget.addEventListener('click', function(event) {}）
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
```

官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。 

简单理解：事件发生后，**跟事件相关的一系列信息数据的集合**都放到这个对象里面，这个对象就是**事件对象 event**，它有很多属性和方法。

比如：

1. 谁绑定了这个事件。 
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。





#### 4.2 事件对象的使用语法

```javascript
eventTarget.onclick = function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
 } 
 eventTarget.addEventListener('click', function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
 }）
```

这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。 

当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。





#### 4.3 事件对象的兼容性解决方案

事件对象本身的获取存在兼容问题： 

1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 
2. 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 

**解决：**

**e = e || window.event;**





#### 4.4 事件对象的常见属性和方法

| 事件对象属性方法    | 说明                                                    |
| ------------------- | ------------------------------------------------------- |
| e.target            | 返回**触发**事件的对象           标准                   |
| e.srcElement        | 返回**触发**事件的对象            非标准，ie6-8使用     |
| e.type              | 返回事件的类型，比如 click  mouseover  不带 on          |
| e.cancelBubble      | 该属性阻止事件冒泡，非标准 ie6-8使用                    |
| e.returnValue       | 该属性阻止默认事件（默认行为），非标准  ie6-8使用       |
| e.preventDefault()  | 该属性阻止默认事件（默认行为），标准 ，比如不让链接跳转 |
| e.stopPropagation() | 阻止冒泡  标准                                          |

**e.target 和 this 的区别：** 

**this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）** 

**e.target 是事件触发的元素。**



return false；也能阻止事件默认事件（默认行为），但是return后面的代码不会再执行；





### 5.阻止事件冒泡

#### 5.1 阻止事件冒泡的两种方式

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

##### 阻止事件冒泡

* 标准写法：利用事件对象里面的 stopPropagation()方法

```javascript
e.stopPropagation() 
```

* 非标准写法：IE 6-8 利用事件对象 cancelBubble 属

```javascript
e.cancelBubble = true;
```





#### 5.2 阻止事件冒泡的兼容性解决方案

```javascript
 if(e && e.stopPropagation){ //表示如果有事件对象并且认识e.stopPropagation
 e.stopPropagation();
 }else{
 window.event.cancelBubble = true;
 }
```







### 6. 事件委托（代理、委派）

事件冒泡本身的特性，会带来的坏处，也会**带来的好处**，需要我们灵活掌握。生活中有如下场景：

咱们班有100个学生， 快递员有100个快递， 如果一个个的送花费时间较长。同时每个学生领取的时候，也需 要排队领取，也花费时间较长，何如？ 

**解决方案**： 快递员把100个快递，**委托**给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。 

**优势**： 快递员省事，委托给班主任就可以走了。 同学们领取也方便，因为相信班主任。



```html
<ul>
 <li>知否知否，应该有弹框在手</li>
 <li>知否知否，应该有弹框在手</li>
 <li>知否知否，应该有弹框在手</li>
 <li>知否知否，应该有弹框在手</li>
 <li>知否知否，应该有弹框在手</li>
 </ul>
```

点击每个 li 都会弹出对话框，以前需要给每个 li 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就 会延长整个页面的交互就绪时间。



##### 事件委托

事件委托也称为事件代理， 在 jQuery 里面称为事件委派。

##### 事件委托的原理

**不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。**

以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。

##### 事件委托的作用

我们只操作了一次 DOM ，提高了程序的性







### 7. 常见的鼠标事件

#### 7.1 常用的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击触发     |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

1.禁止鼠标右键菜单 

contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```javascript
document.addEventListener('contextmenu', function(e) {
e.preventDefault();
})
```

2.禁止鼠标选中（selectstart 开始选中）

```javascript
document.addEventListener('selectstart', function(e) {
 e.preventDefault();
 })
```





#### 7.2 鼠标事件对象

**event**对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 **MouseEvent** 和键盘事件对象 **KeyboardEvent**

| 鼠标事件对象 | 说明                                       |
| ------------ | ------------------------------------------ |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的 X 坐标    |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的 Y 坐标    |
| e.pageX      | 返回鼠标相对于文档页面的 X 坐标  IE9+ 支持 |
| e.pageY      | 返回鼠标相对于文档页面的 Y 坐标  IE9+ 支持 |
| e.screenX    | 返回鼠标相对于电脑屏幕的 X 坐标            |
| e.screenY    | 返回鼠标相对于电脑屏幕的 Y 坐标            |



##### 案例：跟随鼠标的天使

**这个天使图片一直跟随鼠标移动**

![image-20211127184848874](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127184848874.png)

**案例分析**

① 鼠标不断的移动，使用鼠标移动事件： mousemove 

② 在页面中移动，给document注册事件 

③ 图片要移动距离，而且不占位置，我们使用绝对定位即可 

④ 核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的 top和left 值就可以移动图片



**代码实现**

```javascript
var pic = document.querySelector('img');
document.addEventListener('mousemove', function(e) {
var x = e.pageX;
var y = e.pageY;
pic.style.top = y - 40 + 'px';
pic.style.left = x - 50 + 'px';
})
```







### 8. 常用的键盘事件对象

#### 8.1 常用的键盘事件

事件除了使用鼠标触发，还可以使用键盘触发。

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 莫格按键被按下时触发   **但是它不识别功能键，比如ctrl  shift 箭头 等** |

注意： 

1. **如果使用addEventListener 不需要加 on** 
2. **onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。** 
3.  **三个事件的执行顺序是： keydown -- keypress --- keyup**





#### 8.2 键盘事件对象

| 键盘事件对象属性 | 说明               |
| ---------------- | ------------------ |
| keyCode          | 返回该键的ASCII 值 |

**注意：** 

**onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。** 

**在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键）** 

**Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值**





#### 8.3 ASCII 表

![image-20211127185829561](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127185829561.png)





##### 案例：模拟京东按键输入内容

当我们按下 s 键， 光标就定位到搜索框



**案例分析**

① 核心思路： 检测用户是否按下了s 键，如果按下s 键，就把光标定位到搜索框里面 

② 使用键盘事件对象里面的keyCode 判断用户按下的是否是s键 

③ 搜索框获得焦点： 使用 js 里面的 focus() 方法



**代码实现**

```javascript
var search = document.querySelector('input');
document.addEventListener('keyup', function(e) {
// console.log(e.keyCode);
if (e.keyCode === 83) {
search.focus();
}
})
```





#### 案例：模拟京东快递单号查询

要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。

![image-20211127193049535](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127193049535.png)

**案例分析**

① 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的文字 

② 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容 

③ 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子 

**④ 注意： keydown 和 keypress 在文本框里面的特点： 他们两个事件触发的时候，文字还 没有落入文本框中。** 

**⑤ keyup事件触发的时候， 文字已经落入文本框里面了** 

⑥ 当我们失去焦点，就隐藏这个con盒子 

⑦ 当我们获得焦点，并且文本框内容不为空，就显示这个con盒子







****

## BOM 浏览器对象模型

### 1. BOM 概述

#### 1.1 什么是 BOM

BOM（Browser Object Model）即**浏览器对象模型**，它提供了独立于内容而与**浏览器窗口进行交互的对象**，其核心 对象是 window

BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 

BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏 览器标准的一部分。

##### DOM

* 文档对象模型 
* DOM 就是把「文档」当做一个「对象」来看待 
* DOM 的顶级对象是 document
* DOM 主要学习的是操作页面元素 
* DOM 是 W3C 标准规范

##### BOM

* 浏览器对象模型
* 把「浏览器」当做一个「对象」来看待
* BOM 的顶级对象是 window 
* BOM 学习的是浏览器窗口交互的一些对象 
* BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差





#### 1.2 BOM 的构成

BOM 比 DOM 更大，它包含 DOM

![image-20211127223111041](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127223111041.png)

**window 对象是浏览器的顶级对象**，它具有双重角色。 

1. 它是 JS 访问浏览器窗口的一个接口。

2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。 

   **注意：window下的一个特殊属性 window.name**





### 2. window 对象的常见属性

#### 2.1 窗口加载事件

```java
window.onload = function(){}
或者
window.addEventListener("load",function(){});
```

window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS  文件等), 就调用的处理函数。

**注意：**

1. 有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。 
2. window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。
3.  如果使用 addEventListener 则没有限制



```javascript
document.addEventListener('DOMContentLoaded',function(){})
```

DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 

Ie9以上才支持 

如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适





#### 2.2 调整窗口大小事件

```javascript
window.onresize = function(){}
window.addEventListener("resize",function(){});
```

window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。

**注意：**

1. 只要窗口大小发生像素变化，就会触发这个事件。 
2. 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度







### 3. 定时器

#### 3.1 两种定时器

window 对象给我们提供了 2 个非常好用的方法-定时器。

* setTimeout()  
* setInterval() 



#### 3.2 setTimeout() 定时器

```javascript
window.setTimeout(调用函数, [延迟的毫秒数]);
```

setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。 

**注意：** 

1. window 可以省略。 
2. 这个调用函数可以**直接写函数，或者写函数名**或者采取字符串‘函数名()'三种形式。第三种不推荐 
3. 延迟的毫秒数省略默认是 0，如果写，必须是毫秒。 
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。

```javascript
 window.setTimeout(调用函数, [延迟的毫秒数]);
```

setTimeout() 这个调用函数我们也称为**回调函数 callback** 

普通函数是按照代码顺序直接调用。 

而这个函数，**需要等待**时间，时间到了才去调用这个函数，因此称为回调函数。 

简单理解： 回调，就是回头调用的意思。上一件事干完，再**回**头再**调**用这个**函数**。 

以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调 函数。



##### 案例：5秒后自动关闭广告

**案例分析**

① 核心思路：5秒之后，就把这个广告隐藏起来 

② 用定时器setTimeout

**代码实现**

```javascript
var ad = document.querySelector('.ad');
setTimeout(function() {
    ad.style.display = 'none';
}, 5000);
```





#### 3.3 停止 setTimeout() 定时器

```javascript
 window.clearTimeout(timeoutID)
```

clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。 

**注意：** 

1. window 可以省略。 
2. 里面的参数就是定时器的标识符 。





#### 3.4 setInterval() 定时器

```javascript
 window.setInterval(回调函数, [间隔的毫秒数]);
```

setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。

**注意：**

1. window 可以省略。 
2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()' 三种形式。 
3. 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。 
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
5. 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。



##### 案例：倒计时

![image-20211127225109413](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127225109413.png)

**案例分析：**

① 这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval） 

② 三个黑色盒子里面分别存放时分秒 

③ 三个黑色盒子利用innerHTML 放入计算的小时 分钟 秒数 

④ 第一次执行也是间隔毫秒数，因此刚刷新页面会有空白 

⑤ 最好采取封装函数的方式， 这样可以先调用一次这个函数，防止刚开始刷新页面有空白问 题





#### 3.5 停止 setInterval() 定时器

```javascript
 window.clearInterval(intervalID);
```

clearInterval()方法取消了先前通过调用 setInterval()建立的定时器

**注意：** 

1. window 可以省略。 
2. 里面的参数就是定时器的标识符 。





##### 案例：发送短信

点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信

![image-20211127230102157](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127230102157.png)

**案例分析**

① 按钮点击之后，会禁用 disabled 为true  

② 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改 

③ 里面秒数是有变化的，因此需要用到定时器 

④ 定义一个变量，在定时器里面，不断递减 

⑤ 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态。





#### 3.6 this

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this 的最终指向的是那个调用它的对象 

现阶段，我们先了解一下几个this指向 

1. 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window） 
2. 方法调用中谁调用this指向谁 
3. 构造函数中this指向构造函数的实例





#### 练习：时钟

课后同学们做一个电子时钟，显示当前的年月日，时分秒，要求自动变化

![image-20211127230349290](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127230349290.png)







### 4. JS 执行机制

#### 4.1 JS 是单线程

JavaScript 语言的一大特点就是**单线程**，也就是说，**同一个时间只能做一件事**。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对 某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。



#### 4.2 一个问题

以下代码执行的结果是什么？

```javascript
console.log(1);
 setTimeout(function () {
 console.log(3);
 }, 1000);
 console.log(2);
```

那么以下代码执行的结果又是什么？

```javascript
 console.log(1);
 setTimeout(function () {
 console.log(3);
 }, 0);
 console.log(2);
```



#### 4.3 同步和异步

为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了**同步**和**异步**。

##### 同步

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

##### 异步

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

**他们的本质区别： 这条流水线上各个流程的执行顺序不同。**



##### 同步任务

同步任务都在主线程上执行，形成一个**执行栈**。

![image-20211127230909869](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127230909869.png)

##### 异步任务

JS 的异步是通过回调函数实现的。 

一般而言，异步任务有以下三种类型: 

1. 普通事件，如 click、resize 等 
2. 资源加载，如 load、error 等 
3. 定时器，包括 setInterval、setTimeout 等 
4. 异步任务相关**回调函数**添加到**任务队列**中（任务队列也称为消息队列）。

![image-20211127231041057](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127231041057.png)



#### 4.4 JS 执行机制

1. 先执行执行栈中的**同步任务**。 
2. 异步任务（回调函数）放入任务队列中。 
3.  一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行。

![image-20211127231303872](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127231303872.png)

```javascript
console.log(1);
 document.onclick = function() {
 console.log('click');
 }
 console.log(2);
 setTimeout(function() {
 console.log(3)
 }, 3000)
```

![image-20211127231428753](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127231428753.png)

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为**事件循环（ event loop）**。





### 5. location 对象

#### 5.1 什么是 location 对象

window 对象给我们提供了一个 l**ocation 属性**用于**获取或设置窗体的 URL**，并且可以用于**解析 URL** 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为 **location 对象**



#### 5.2 URL

**统一资源定位符 (Uniform Resource Locator, URL)** 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 

URL 的一般语法格式为：

```javascript
protocol://host[:port]/path/[?query]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议  常用的http，ftp，maito等                           |
| host     | 主机（域名）  www.baidu.com                                  |
| port     | 端口号  可选，省略时使用方案默认端口，如http的默认端口为80   |
| path     | 路径  由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数  以键值对的形式，通过 & 符号分隔开来                    |
| fragment | 片段  #后面内容  常见于链接 锚点                             |



#### 5.3 location 对象的属性

| location对象属性  | 返回值                               |
| ----------------- | ------------------------------------ |
| location.href     | 获取或者设置整个URL                  |
| location.host     | 返回主机（域名）  www.baidu.com      |
| location.port     | 返回端口号  如果未写返回空字符串     |
| location.pathname | 返回路径                             |
| lacation.search   | 返回参数                             |
| location.hash     | 返回片段  #后面内容，常见于链接 锚点 |

**重点记住： href 和 search**



##### 案例：5秒钟之后自动跳转页面

**案例分析**

① 利用定时器做倒计时效果 

② 时间到了，就跳转页面。 使用 location.href



##### 案例：获取URL参数数据

主要练习数据在不同页面中的传递。

**案例分析**

① 第一个登录页面，里面有提交表单， action 提交到 index.html页面 

② 第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果 

③ 第二个页面之所以可以使用第一个页面的数据，是利用了URL 里面的 location.search参数 

④ 在第二个页面中，需要把这个参数提取。 

⑤ 第一步去掉？ 利用 substr  

⑥ 第二步 利用=号分割 键 和 值 split(‘=‘) ⑦ 第一个数组就是键 第二个数组就是





#### 5.4 location 对象的方法

| location对象方法   | 返回值                                                       |
| ------------------ | ------------------------------------------------------------ |
| location.assign()  | 跟 href一样，可以跳转页面（也称为重定向页面）                |
| location.repalce() | 替换当前页面，因为不记录历史，所以不能后退页面               |
| lacation.reload()  | 重新加载界面，相当于刷新按钮或者 F5 ，如果参数为true表示强制刷新（ctrl+F5） |







### 6. navigator 对象

navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客 户机发送服务器的 user-agent 头部的值。 

下面前端代码可以判断用户那个终端打开页面，实现跳转

```javascript
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|
Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS
|Symbian|Windows Phone)/i))) {
 window.location.href = ""; //手机
} else {
 window.location.href = ""; //电脑
}
```





#### 7. history 对象

window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。

| history对象方法 | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| back()          | 实现后退功能                                                 |
| forward()       | 实现前进功能                                                 |
| go(参数)        | 前进后退功能，参数如果时1则前进一个页面，如果时-1则后退一个页面 |

history 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到

![image-20211127234233081](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127234233081.png)







***

## PC 端网页特效

### 1. 元素偏移量 offfset 系列

### 1.1 offset 概述

offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以**动态的**得到该元素的位置（偏移）、大小等。 

* 获得元素距离带有定位父元素的位置 
* 获得元素自身的大小（宽度高度）
* 注意： 返回的数值都不带单位 

offset 系列常用属性：

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |
| element.offsetLeft   | 返回元素相对带有定位父元素左边框的偏移                       |
| element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度，返回数值不带单位    |
| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |



#### 1.2 offset 与 style 区别

##### offset

* offset 可以得到任意样式表中的样式值 
* offset 系列获得的数值是没有单位的 
* offsetWidth 包含padding+border+width  offsetWidth 等属性是只读属性，只能获取不能赋值 
* **所以，我们想要获取元素大小位置，用offset更合适**

##### style

* style 只能得到行内样式表中的样式值 
* style.width 获得的是带有单位的字符串 
* style.width 获得不包含padding和border 的值 
* style.width 是可读写属性，可以获取也可以赋值 
* **所以，我们想要给元素更改值，则需要用style改变**

![image-20211127235755520](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127235755520.png)



##### 案例：获取鼠标在盒子内的坐标

**案例分析**

① 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。 

② 首先得到鼠标在页面中的坐标（e.pageX, e.pageY） 

③ 其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop) 

④ 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标 

⑤ 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件 mousemove



**代码实现**

```javascript
var box = document.querySelector('.box');
box.addEventListener('mousemove', function(e) {
var x = e.pageX - this.offsetLeft;
var y = e.pageY - this.offsetTop;
this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
})
```



##### 案例：模态框拖拽

弹出框，我们也称为模态框。 

1. 点击弹出层， 会弹出模态框， 并且显示灰色半透明的遮挡层。 
2. 点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。 
3. 鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。 
4. 鼠标松开，可以停止拖动模态框移动。

**案例分析**

① 点击弹出层， 模态框和遮挡层就会显示出来 display:block; 

② 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none; 

③ 在页面中拖拽的原理： 鼠标按下并且移动， 之后松开鼠标 

④ 触发事件是鼠标按下 mousedown， 鼠标移动mousemove 鼠标松开 mouseup 

⑤ 拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值， 这样模态框可以跟着鼠标走了 

⑥ 鼠标按下触发的事件源是 最上面一行，就是 id 为 title  

⑦ 鼠标的坐标 减去 鼠标在盒子内的坐标， 才是模态框真正的位置。 

 **⑧ 鼠标按下，**我们要得到鼠标在盒子的坐标。 

**⑨ 鼠标移动**，就让模态框的坐标 设置为 ： 鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。 

**⑩ 鼠标松开**，就停止拖拽，就是可以让鼠标移动事件解除 



##### 案例：仿京东放大镜

**案例分析**

① 整个案例可以分为三个功能模块 

② 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能 

③ 黄色的遮挡层跟随鼠标功能。 

④ 移动黄色遮挡层，大图片跟随移动功能。

**功能1：**

① **鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能** 

② 就是显示与隐藏

**功能2：**

① 黄色的遮挡层跟随鼠标功能。 

② 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。 

③ 首先是获得鼠标在盒子的坐标。 ④ 之后把数值给遮挡层做为left 和top值。 

⑤ 此时用到鼠标移动事件，但是还是在小图片盒子内移动。 

⑥ 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。 

⑦ 遮挡层不能超出小图片盒子范围。 

⑧ 如果小于零，就把坐标设置为0 

⑨ 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离 

⑩ 遮挡层的最大移动距离： 小图片盒子宽度 减去 遮挡层盒子宽度

![image-20211128000652402](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128000652402.png)

![image-20211128000705125](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128000705125.png)







### 2. 元素可视区 client 系列

**client** 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列 的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回左边框的大小                                             |
| element.clientWidth  | 返回自身宽度，包括padding、内容区的宽度，不含边框，返回数组不带单位 |
| element.clientHeight | 返回自身高度，包括padding、内容区的宽度，不含边框，返回数组不带单位 |

![image-20211128094740319](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128094740319.png)

##### 案例：淘宝 flexible.js 源码分析

##### 立即执行函数

立即执行函数：不需要调用，立马能够自己执行的函数，也可以传递参数进去，在第二个()里进行实参传递

**语法规范**：

```javascript
 (function() {})() 或者 (function(){}()) 
```

**主要作用**： 创建一个独立的作用域。 避免了变量命名冲突（变量污染）问题

第二个小（）可以看作是调用函数

JS文件中，会有大量的变量命名，特别是Echarts使用中，需要大量初始化Echarts对象。

为了防止变量名冲突（变量污染），我们采用立即执行函数：

```javascript
(function() {})();
```

```javascript
(function() {
    var num = 10;
})();
(function() {
    var num = 10;
})();
```

**注意：多个立即执行函数中间必须加分号（；）隔开。**



**案例：淘宝 flexible.js 源码分析**

下面三种情况都会刷新页面都会触发 load 事件。 

1. a标签的超链接 

2. F5或者刷新按钮（强制刷新） 

3. 前进后退按钮 但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状 态；实际上是将整个页面都保存在了内存里。 

   所以此时后退按钮不能刷新页面。 

   此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页 面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的 pageshow事件，**注意这个事件给window添加。**







### 元素滚动 scroll 系列

#### 3.1 元素 scroll 系列属性

scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。

| scroll系列属性       | 作用                                           |
| -------------------- | ---------------------------------------------- |
| element.scrollTop    | 返回被卷去的上侧距离，返回数值不带单位         |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位         |
| element.scrollWidth  | 返回自身实际的宽度，不含边框，返回数值不带单位 |
| element.scrollHeight | 返回自身实际的高度，不含边框，返回数值不带单位 |



![image-20211128110850277](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128110850277.png)



#### 3.2 页面被卷去的头部

如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 **onscroll** 事件



##### 案例：仿淘宝固定右侧侧边栏

1. 原先侧边栏是绝对定位 
2. 当页面滚动到一定位置，侧边栏改为固定定位 
3. 页面继续滚动，会让 返回顶部显示出

**案例分析**

① 需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是 document 

② 滚动到某个位置，就是判断页面被卷去的上部值。 

**③ 页面被卷去的头部：可以通过window.pageYOffset 获得** 如果是被卷去的左侧 window.pageXOffset 

④ 注意，**元素被卷去的头部是 element.scrollTop** , 如果是页面被卷去的头部 则是 **window.pageYOffset** 

⑤ 其实这个值 可以通过盒子的 offsetTop 可以得到，如果大于等于这个值，就可以让盒子固定定位了





#### 3.3 页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法： 

1. 声明了 DTD，使用 document.documentElement.scrollTop 
2. 未声明 DTD，使用 document.body.scrollTop 
3. 新方法 window.pageYOffset 和 

```javascript
function getScroll() {
 return {
 left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
 top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
 };
 } 
使用的时候 getScroll().left
```





### 三大系列总结

| 三大系列大小对比    | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| element.offsetWidth | 返回自身包括padding、边框、内容区的宽度，返回数值不带单位    |
| element.clientWidth | 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 |
| element.scrollWidth | 返回自身实际的宽度，不含边框，返回数值不带单位               |

![image-20211128111948242](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128111948242.png)

他们主要用法： 

1. offset系列 经常用于获得元素位置 **offsetLeft offsetTop** 
2. client 经常用于获取元素大小 **clientWidth clientHeight** 
3. scroll 经常用于获取滚动距离 **scrollTop scrollLeft**  
4. 注意页面滚动的距离通过 **window.pageXOffset** 获得







### mouseenter 和 mouseover 的区别

#### mouseenter 鼠标事件

* 当鼠标移动到元素上时就会触发 mouseenter 事件 
* 类似 mouseover，它们两者之间的差别是 
* mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter 只会经过自身盒子触发 
* 之所以这样，就是因为mouseenter不会冒泡 
* 跟mouseenter搭配 鼠标离开 mouseleave 同样不会冒泡







### 4. 动画函数封装

#### 4.1 动画实现原理

**核心原理**：通过定时器 setInterval() 不断移动盒子位置。 

实现步骤： 

1. 获得盒子当前位置 
2. 让盒子在当前位置加上1个移动距离 
3. 利用定时器不断重复这个操作 
4. 加一个结束定时器的条件 
5. 注意此元素需要添加定位，才能使用element.style.left





#### 4.2 动画函数简单封装

注意函数需要传递2个参数，**动画对象**和**移动到的距离**。

```javascript
// 简单动画函数封装 obj 目标对象， target 目标位置
function animate(obj,target) {
    var timer = setInteval(function() {
        if(obj.offsetLeft == target){
            clearInteval(timer);
        }
        obj.style.left = obj.offsetLeft + 1 + 'px';
    }, 30);
}
var div = document.querySelector('div');
// 调用函数
animate(div, 300);
```





#### 4.3 动画函数给不同元素记录不同定时器

如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自 己专门用自己的定时器）。 

核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

```javascript
// 简单动画函数封装 obj 目标对象， target 目标位置
function animate(obj,target) {
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案就是，让我们的元素只有一个定时器执行
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInteval(function() { //这句话实现给不同元素记录不同定时器
        if(obj.offsetLeft == target){
            clearInteval(obj.timer); // 清除也是一样的
        }
        obj.style.left = obj.offsetLeft + 1 + 'px';
    }, 30);
}
var div = document.querySelector('div');
// 调用函数
animate(div, 300);
```





#### 4.4 缓动动画原理

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 

思路： 

1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 
2. 核心算法： (目标值 - 现在的位置 ) / 10 做为每次移动的距离 步长 
3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 
4. **注意步长值需要取整 （前进用Math.ceil，后退用Math.floor)**

**代码实现**

```javascript
// 简单动画函数封装 obj 目标对象， target 目标位置
function animate(obj,target) {
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案就是，让我们的元素只有一个定时器执行
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInteval(function() { //这句话实现给不同元素记录不同定时器
        // 步长值写到计时器的里面
        //var step = Math.ceil((target - obj.offsetLeft)/10);
        var step = (target - obj.offsetLeft)/10;
        step > 0 ? Math.ceil(step):Math.floor(step);
        if(obj.offsetLeft == target){
            clearInteval(obj.timer); // 清除也是一样的
        }
        // 把每次加1 这个步长值改为一个慢慢变小的一个值
        obj.style.left = obj.offsetLeft + step + 'px'; // 把固定的1 换成step实现缓动
    }, 15);
}
var div = document.querySelector('div');
// 调用函数
animate(div, 300);
```

匀速动画：就是盒子当前的位置 + 固定的值 10

缓动动画：就是盒子当前的位置 + 变化的值（(目标值 - 现在的位置 ) / 10）



#### 4.5 动画函数多个目标值之间移动

可以让动画函数从 800 移动到 500。 

当我们点击按钮时候，判断步长是正值还是负值 

1.  如果是正值，则步长 往大了取整 
2. 如果是负值，则步长 向小了取整



#### 4.6 动画函数添加回调函数

**回调函数原理**：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做**回调**。 

回调函数写的位置：定时器结束的位置。

```javascript
// 简单动画函数封装 obj 目标对象， target 目标位置
function animate(obj,target,callback) {
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案就是，让我们的元素只有一个定时器执行
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInteval(function() { //这句话实现给不同元素记录不同定时器
        // 步长值写到计时器的里面
        //var step = Math.ceil((target - obj.offsetLeft)/10);
        var step = (target - obj.offsetLeft)/10;
        step > 0 ? Math.ceil(step):Math.floor(step);
        if(obj.offsetLeft == target){
            clearInteval(obj.timer); // 清除也是一样的
           // 回调函数写到定时器结束里面
            if(callback) {
                callback();
            }
        }
        // 把每次加1 这个步长值改为一个慢慢变小的一个值
        obj.style.left = obj.offsetLeft + step + 'px'; // 把固定的1 换成step实现缓动
    }, 15);
}
var div = document.querySelector('div');
// 调用函数
animate(div, 300, function() {
    div.style.backgroundColor = 'red';
});
```



#### 4.7 动画函数封装到单独JS文件里面

因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。 

1. 单独新建一个JS文件。 
2. HTML文件引入 JS 文





### 5. 常见网页特效案例

#### 案例：网页轮播图

轮播图也称为焦点图，是网页中比较常见的网页特效。 

功能需求： 

1. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。 
2. 点击右侧按钮一次，图片往左播放一张，以此类推， 左侧按钮同理。 
3. 图片播放的同时，下面小圆圈模块跟随一起变化。 
4. 点击小圆圈，可以播放相应图片。 
5. 鼠标不经过轮播图， 轮播图也会自动播放图片。
6. 鼠标经过轮播图模块， 自动播放停止

**案例分析1** 

① 因为js较多，我们单独新建js文件夹，再新建js文件， 引入页面中。 

② 此时需要添加 load 事件。 

**③** **鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。** 

④ 显示隐藏 display 按钮。



**案例分析2**

① 动态生成小圆圈 

② 核心思路：小圆圈的个数要跟图片张数一致 

③ 所以首先先得到ul里面图片的张数（图片放入li里面，所以就是li的个数） 

④ 利用循环动态生成小圆圈（这个小圆圈要放入ol里面） 

⑤ 创建节点 createElement(‘li’) 

⑥ 插入节点 ol. appendChild(li) 

⑦ 第一个小圆圈需要添加 current 



**案例分析3**

① **小圆圈的排他思想** 

② 点击当前小圆圈，就添加current类 

③ 其余的小圆圈就移除这个current类 

④ 注意： 我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了。



**案例分析4**

① **点击小圆圈滚动图片** 

② 此时用到animate动画函数，将js文件引入（注意，因为index.js 依赖 animate.js 所以，animate.js 要写到 index.js 上面） 

③ 使用动画函数的前提，该元素必须有定位 

④ 注意是ul 移动 而不是小li  

⑤ 滚动图片的核心算法： 点击某个小圆圈 ， 就让图片滚动 小圆圈的**索引号乘以图片的宽度**做为ul移动距离 

⑥ 此时需要知道小圆圈的索引号， 我们可以在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定 义属性即可。



**案例分析5**

**① 点击右侧按钮一次，就让图片滚动一张。** 

② 声明一个变量num， 点击一次，自增1， 让这个变量乘以图片宽度，就是 ul 的滚动距离。 

③ 图片无缝滚动原理 

④ 把ul 第一个li 复制一份，放到ul 的最后面 

⑤ 当图片滚动到克隆的最后一张图片时， 让ul 快速的、不做动画的跳到最左侧： left 为0 

⑥ 同时num 赋值为0，可以从新开始滚动图片了



**案例分析6**

**① 克隆第一张图片** 

② 克隆ul 第一个li cloneNode() 加true 深克隆 复制里面的子节点 false 浅克隆 

③ 添加到 ul 最后面 appendChild



**案例分析7**

① **点击右侧按钮， 小圆圈跟随变化** 

② 最简单的做法是再声明一个变量circle，每次点击自增1，注意，左侧按钮也需要这个变量，因此要声明全局变量。 

③ 但是图片有5张，我们小圆圈只有4个少一个，必须加一个判断条件 ④ 如果circle == 4 就 从新复原为 



**案例分析8**

**① 自动播放功能** 

② 添加一个定时器 

③ 自动播放轮播图，实际就类似于点击了右侧按钮 

④ 此时我们使用手动调用右侧按钮点击事件 arrow_r.click() 

⑤ 鼠标经过focus 就停止定时器 

⑥ 鼠标离开focus 就开启定时





#### 5.1 节流阀

防止轮播图按钮连续点击造成播放过快。 

节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 

核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。 

开始设置一个变量 var flag = true; 

if(flag) {flag = false; do something}  关闭水龙头 

利用回调函数 动画执行完毕， flag = true 打开水龙头



##### 案例：返回顶部

滚动窗口至文档中的特定位置。 window.scroll(x, y)  

注意，里面的x和y 不跟单位，直接写数字

**案例分析**

① 带有动画的返回顶部 

② 此时可以继续使用我们封装的动画函数 

③ 只需要把所有的left 相关的值 改为 跟 页面垂直滚动距离相关就可以了 

④ 页面滚动了多少，可以通过 window.pageYOffset 得到 

⑤ 最后是页面滚动，使用 window.scroll(x,y) 





##### 案例：筋斗云案例

鼠标经过某个小li， 筋斗云跟这到当前小li位置 

鼠标离开这个小li， 筋斗云复原为原来的位置 

鼠标点击了某个小li， 筋斗云就会留在点击这个小li 的位置

**案例分析**

① 利用动画函数做动画效果 

② 原先筋斗云的起始位置是0 

③ 鼠标经过某个小li， 把当前小li 的 offsetLeft 位置 做为目标值即可 

④ 鼠标离开某个小li， 就把目标值设为 0 

⑤ 如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置







***

## 移动端网页特效

### 1. 触屏事件

#### 1.1 触屏事件概述

移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动 端也有自己独特的地方。比如**触屏事件 touch**（也称触摸事件），Android 和 IOS 都有。 

touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控 笔）对屏幕或者触控板操作。 

常见的触屏事件如下：

| 触屏touch事件 | 说明                        |
| ------------- | --------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发 |
| touchmove     | 手指在一个DOM上滑动时触发   |
| touchend      | 手指从一个DOM上移开时触发   |



#### 1.2 触摸事件对象（TouchEvent）

TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多 个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 

touchstart、touchmove、touchend 三个事件都会各自有事件对象。 

触摸事件对象重点我们看三个常见对象列表：

| 触摸列表      | 说明                                               |
| ------------- | -------------------------------------------------- |
| touches       | 正在触摸屏幕的所有手指的一个列表                   |
| targetTouches | 正在触摸当前 DOM 元素上的手指的一个列表            |
| changeTouches | 手指状态发生了改变的列表，从无到有，从有到无的变化 |

**因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes**





#### 1.3 移动端拖动元素

1. touchstart、touchmove、touchend 可以实现拖动元素 
2. 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY  
3. 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 
4. 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 

拖动元素三步曲： 

（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 

（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 

（3） 离开手指 touchend: 

**注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault()**



###  2. 移动端常见特效

#### 案例：移动端轮播图

移动端轮播图功能和基本PC端一致。 

1. 可以自动播放图片 
2. 手指可以拖动播放轮播图

**案例分析1**

**① 自动播放功能** 

② 开启定时器 

③ 移动端移动，可以使用translate 移动 

④ 想要图片优雅的移动，请添加过渡效果



**案例分析2**

**① 自动播放功能-无缝滚动** 

② 注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断 

③ 此时需要添加检测过渡完成事件 transitionend  

④ 判断条件： 如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0 

⑤ 此时图片，去掉过渡效果，然后移动 

⑥ 如果索引号小于0， 说明是倒着走， 索引号等于2  

⑦ 此时图片，去掉过渡效果，然后移动





#### 2.1 classList 属性

classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。 

该属性用于在元素中添加，移除及切换 CSS 类。有以下方法

##### 添加类：

element.classList.add（’类名’）；

```javascript
focus.classList.add(‘current’);
```

##### 移除类：

element.classList.remove（’类名’）;

```javascript
focus.classList.remove(‘current’);
```

##### 切换类：

element.classList.toggle（’类名’）；

```javascript
focus.classList.toggle(‘current’);
```

注意以上方法里面，所有类名都不带点



**案例分析3**

**① 小圆点跟随变化效果** 

② 把ol里面li带有current类名的选出来去掉类名 **remove** 

③ 让当前索引号 的小li 加上 current **add** 

**④ 但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里**



**案例分析4**

**① 手指滑动轮播图** 

**② 本质就是ul跟随手指移动，简单说就是移动端拖动元素** 

③ 触摸元素 touchstart： 获取手指初始坐标 

④ 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 

⑤ 离开手指 touchend: 根据滑动的距离分不同的情况 

⑥ 如果移动距离小于 某个像素 就回弹原来位置 

⑦ 如果移动距离大于某个像素就上一张下一张滑动。 

⑧ 滑动也分为左滑动和右滑动 判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑 

⑨ 如果是左滑 就播放下一张 （index++） 

⑩ 如果是右滑 就播放上一张 (index--)





##### 案例：返回顶部

当页面滚动某个地方，就显示，否则隐藏 

点击可以返回顶部

**案例分析**

① 滚动某个地方显示 

② 事件： scroll 页面滚动事件 

③ 如果被卷去的头部（window.pageYOffset ）大于某个数值 

④ 点击， window.scroll(0,0) 返回顶部





#### 2.2 click 延时解决方案

移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。 

解决方案：

1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。

```javascript
 <meta name="viewport" content="user-scalable=no">
```

2. 利用touch事件自己封装这个事件解决 300ms 延迟。 

   原理就是： 

   1. 当我们手指触摸屏幕，记录当前触摸时间 
   2. 当我们手指离开屏幕， 用离开的时间减去触摸的时间 
   3. 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击

**代码实现**

```javascript
//封装tap，解决click 300ms 延时
function tap (obj, callback) {
 var isMove = false;
 var startTime = 0; // 记录触摸时候的时间变量
 obj.addEventListener('touchstart', function (e) {
 startTime = Date.now(); // 记录触摸时间
 });
 obj.addEventListener('touchmove', function (e) {
 isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击
 });
 obj.addEventListener('touchend', function (e) {
 if (!isMove && (Date.now() - startTime) < 150) { // 如果手指触摸和离开时间小于150ms 算点击
 callback && callback(); // 执行回调函数
 }
 isMove = false; // 取反 重置
 startTime = 0;
 });
}
//调用 
 tap(div, function(){ // 执行代码 });
```



3. 使用插件。 fastclick 插件解决 300ms 延迟。







### 3. 移动端常用开发插件

#### 3.1 什么是插件

移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？ 

JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。 

特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 

我们以前写的animate.js 也算一个最简单的插件



fastclick 插件解决 300ms 延迟。 使用延时 

GitHub官网地址： https://github.com/ftlabs/fastclick



#### 3.2插件的使用

1. 引入 js 插件文件。 
2. 按照规定语法使用。

fastclick 插件解决 300ms 延迟。 使用延时 

GitHub官网地址： **https://github.com/ftlabs/fastclick**

```javascript
if ('addEventListener' in document) {
 document.addEventListener('DOMContentLoaded', function() {
 FastClick.attach(document.body);
 }, false);
}
```





#### 3.3 Swiper 插件的使用

中文官网地址： **https://www.swiper.com.cn/**  

1. 引入插件相关文件。 
2. 按照规定语法使用





#### 3.4 其他移动端常见插件

* superslide： http://www.superslide2.com/ 
* iscroll： https://github.com/cubiq/





#### 3.5 插件的使用总结

1. 确认插件实现的功能 
2. 去官网查看使用说明 
3. 下载插件 
4. 打开demo实例文件，查看需要引入的相关文件，并且引入 
5. 复制demo实例文件中的结构html，样式css以及js代码





#### 3.6 练习-移动端视频插件 zy.media.js

H5 给我们提供了 video 标签，但是浏览器的支持情况不同。 

不同的视频格式文件，我们可以通过source 解决。 

但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。 

这个时候我们可以使用插件方式来制作。







### 4. 移动端常用开发框架

#### 4.1 框架概述

框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架 本身，使用者要按照框架所规定的某种规范进行开发。

插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。

前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端 

前端常用的移动端插件有 swiper、superslide、iscroll等



框架： 大而全，一整套解决方案 

插件： 小而专一，某个功能的解决方案





#### 4.2 Bootstrap

Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。 

它能开发PC端，也能开发移动端 

Bootstrap JS插件使用步骤： 

1. 引入相关js 文件 
2. 复制HTML 结构 
3. 修改对应样式 
4. 修改相应JS 参数







***

## 本地存储

### 1. 本地存储

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经 常性在本地存储大量的数据，HTML5规范提出了相关解决方案。

#### 本地存储特性

1. 数据存储在用户浏览器中 
2. 设置、读取方便、甚至页面刷新不丢失数据 
3. 容量较大，sessionStorage约5M、localStorage约20M 
4. 只能存储字符串，可以将对象JSON.stringify() 编码后存储





### 2. window.sessionStorage

1. 生命周期为关闭浏览器窗口
2. 在同一个窗口(页面)下数据可以共享
3. 以键值对的形式存储使用

#### 存储数据：

```javascript
sessionStorage.setItem(key, value)
```

#### 获取数据:

```javascript
sessionStorage.getItem(key)
```

#### 删除数据：

```javascript
sessionStorage.removeItem(key)
```

#### 删除所有数据：

```javascript
sessionStorage.clear()
```





### 3. window.localStorage

1. 声明周期永久生效，除非手动删除 否则关闭页面也会存在 
2. 可以多窗口（页面）共享（同一浏览器可以共享） 
3. 以键值对的形式存储使用

#### 存储数据：

```javascript
localStorage.setItem(key, value)
```

#### 获取数据：

```javascript
localStorage.getItem(key)
```

#### 删除数据：

```javascript
localStorage.removeItem(key)
```

#### 删除所有数据：

```javascript
localStorage.clear()
```





#### 案例：记住用户名

如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名

**案例分析**

① 把数据存起来，用到本地存储 

② 关闭页面，也可以显示用户名，所以用到localStorage 

③ 打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框 

④ 当复选框发生改变的时候 change事件 

⑤ 如果勾选，就存储，否则就移除







****

## jQuery入门

### 1. jQuery 概述

#### 1.1 JavaScript 库

仓库：可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了。

**JavaScript库：**即 library，是一个**封装好**的特定**的集合**（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。

简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。

比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。



##### 常见的JavaScript 库

* jQuery

* Prototype

* YUI

* Dojo

* Ext JS

* 移动端的zepto

这些库都是对原生 JavaScript 的封装，**内部都是用 JavaScript 实现的**，我们主要学习的是 **jQuery**。





#### 1.2 jQuery 的概念

**jQuery** 是一个快速、简洁的 **JavaScript 库**，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。

j 就是 JavaScript；  Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。

**jQuery 封装了 JavaScript 常用的功能代码**，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。

**学习jQuery本质： 就是学习调用这些函数（方法）。**

**jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它**，从而提高开发效率。

![image-20211128205016803](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128205016803.png)



#### 1.2 jQuery 的优点

* 轻量级。核心文件才几十kb，不会影响页面加载速度

* 跨浏览器兼容。基本兼容了现在主流的浏览器

* 链式编程、隐式迭代

* 对事件、样式、动画支持，大大简化了DOM操作

* 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等

* 免费、开源





### 2. jQuery 的基本使用

#### 2.1 jQuery 的下载

官网地址： https://jquery.com/

版本：

* 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新

* 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新

* 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本

各个版本的下载：https://code.jquery.com/





#### 2.2 jQuery 的使用步骤

1. 引入 jQuery 文件

2. 使用即可





#### 2.3 jQuery 的入口函数

```javascript
$(function () {   
    ...  // 此处是页面 DOM 加载完成的入口
 }) ;
```

```javascript
$(document).ready(function(){
   ...  //  此处是页面DOM加载完成的入口
});       
```

1. 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。

2. 相当于原生 js 中的 DOMContentLoaded。

3. 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。

4. 更推荐使用第一种方式。





#### 2.4 jQuery 的顶级对象 $

1. $ 是 jQuery 的别称，在代码中可以使用 jQuery 代替 $，但一般为了方便，通常都直接使用 $ 。

2. $ 是jQuery 的顶级对象， 相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。





#### 2.5 jQuery 对象和 DOM 对象

1. 用原生 JS 获取来的对象就是 DOM 对象

2. jQuery 方法获取的元素就是 jQuery 对象。

3. jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。

**注意**：

只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。



DOM 对象与 jQuery 对象之间是可以相互转换的。

因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。

1. DOM 对象转换为 jQuery 对象： $(DOM对象)

```javascript
$('div')         
```

2. jQuery 对象转换为 DOM 对象（两种方式）

```javascript
$('div') [index]       index 是索引号           
```

```javascript
$('div') .get(index)    index 是索引号      
```





## jQuery 常用API

### 1. jQuery 选择器

#### 1.1 jQuery 基础选择器

原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。

```javascript
$(“选择器”)   //  里面选择器直接写 CSS 选择器即可，但是要加引号      
```

| 名称       | 用法            | 描述                  |
| ---------- | --------------- | --------------------- |
| ID选择器   | $("#id")        | 获取指定ID的元素      |
| 全选选择器 | $('*')          | 匹配所有元素          |
| 类选择器   | $(".class")     | 获取同一类class的元素 |
| 标签选择器 | $("div")        | 获取同一类标签的元素  |
| 并集选择器 | $("div,p,li")   | 选取多个元素          |
| 交集选择器 | $("li.current") | 交集元素              |



#### 1.2 jQuery 层级选择器

| 名称       | 用法        | 描述                                                         |
| ---------- | ----------- | ------------------------------------------------------------ |
| 子代选择器 | $("ul>li"); | 使用>号，获取亲儿子层级的元素；注意，并不会获取孙子层级的元素 |
| 后代选择器 | $("ul li"); | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等   |





#### 知识铺垫

jQuery 设置样式

```javascript
$('div').css('属性', '值')      
```





#### 1.3 隐式迭代（重要）

遍历内部 DOM 元素（伪数组形式存储）的过程就叫做**隐式迭代**。

简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。





#### 1.4 jQuery 筛选选择器

| 语法       | 用法          | 描述                                                      |
| ---------- | ------------- | --------------------------------------------------------- |
| :first     | $("li:first") | 获取第一个元素                                            |
| :last      | $("li:last")  | 获取最后一个元素                                          |
| :eq(index) | $("li:eq(2)") | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 |
| :odd       | $("li:odd")   | 获取到的li元素中，选择索引号为奇数的元素                  |
| :even      | $("li:even")  | 获取到的li元素中，选择索引号为偶数的元素                  |





#### 1.5 jQuery 筛选方法（重点）

| 语法               | 用法                            | 说明                                                   |
| ------------------ | ------------------------------- | ------------------------------------------------------ |
| parent()           | $("li").parent();               | 查找父级                                               |
| children(selector) | $("ul").children("li");         | 相当于$("ul>li"),最近一级（亲儿子）                    |
| find(selector)     | $("ul").find("li");             | 相当于$("ul li"),后代选择器                            |
| siblings(selector) | $(".first").siblings("li");     | 查找兄弟节点，不包括自己本身                           |
| nextAll([expr])    | $(".first").nextAll()；         | 查找当前元素之后所有的同辈元素                         |
| prevALl([expr])    | $(".first").prevAll();          | 查找当前元素之前所有的同辈元素                         |
| hasClass(class)    | $("div").hasClass("protected"); | 检查当前的元素是否含有某个特定的类，如果有，则返回true |
| ep(index)          | $("li").eq(2);                  | 相当于$("li:eq(2)"),index从0开始                       |

**重点记住： parent() children() find() siblings() eq()**





#### 1.6 jQuery 里面的排他思想

想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。

```javascript
$(this).css(“color”,”red”);
$(this).siblings(). css(“color”,””);
```



#####  案例：淘宝服饰精品案例

**案例分析**

① 核心原理：鼠标经过左侧盒子某个小li，就让内容区盒子相对应图片显示，其余的图片隐藏。

② 需要得到当前小li 的索引号，就可以显示对应索引号的图片

③ jQuery 得到当前元素索引号 **$(this).index()** 

④ 中间对应的图片，可以通过 eq(index) 方法去选择 

⑤ 显示元素 show()  隐藏元素 hide()





#### 1.7 链式编程

链式编程是为了节省代码量，看起来更优雅。

```javascript
$(this).css('color', 'red').sibling().css('color', '');     
```

使用链式编程一定注意是哪个对象执行样式.







### 2. jQuery 样式操作

jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。

1. 参数只写属性名，则是返回属性值

```javascript
$(this).css(''color'');
```

2. 参数是**属性名，属性值，逗号分隔**，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号

```javascript
$(this).css(''color'', ''red'');
```

3. 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号，

```javascript
$(this).css({ "color":"white","font-size":"20px"});
```





#### 2.2 设置类样式方法

作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。

1. 添加类

```javascript
$(“div”).addClass(''current'');
```

2. 移除类

```javascript
$(“div”).removeClass(''current'');
```

3. 切换类

```javascript
$(“div”).toggleClass(''current'');
```



##### 案例：tab 栏切换

**案例分析**

① 点击上部的li，当前li 添加current类，其余兄弟移除类。

② 点击的同时，得到当前li 的索引号

③ 让下部里面相应索引号的item显示，其余的item隐藏





### 2.3 类操作与className区别

原生 JS 中 className 会覆盖元素原先里面的类名。

jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。







### 3. jQuery 效果

jQuery 给我们封装了很多动画效果，最为常见的如下：



![image-20211128223159326](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211128223159326.png)



#### 3.1 显示隐藏效果

##### 显示效果

##### 1. 显示语法规范

```javascript
show([speed,[easing],[fn]])
```

##### 2. 显示参数

（1）参数都可以省略， 无动画直接显示。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 隐藏效果

##### 1. 隐藏语法规范

```javascript
hide([speed,[easing],[fn]])
```

##### 2. 隐藏参数

（1）参数都可以省略， 无动画直接显示。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 切换效果

##### 1. 切换语法规范

```javascript
toggle([speed,[easing],[fn]])
```

##### 2. 切换参数

（1）参数都可以省略， 无动画直接显示。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。

 **建议：平时一般不带参数，直接显示隐藏即可。**





#### 3.2 滑动效果

##### 下滑效果

##### 1. 下滑效果语法规范

```javascript
slideDown([speed,[easing],[fn]])
```

##### 2. 下滑效果参数

（1）参数都可以省略。

（2）speed:三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing:(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 上滑效果

##### 1. 上滑效果语法规范

```javascript
slideUp([speed,[easing],[fn]])
```

##### 2. 上滑效果参数

（1）参数都可以省略。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。





#### 3.3 事件切换

```javascript
hover([over,]out)
```

（1）over:鼠标移到元素上要触发的函数（相当于mouseenter）

（2）out:鼠标移出元素要触发的函数（相当于mouseleave）

（3）如果只写一个函数，则鼠标经过和离开都会触发它





#### 3.4 动画队列及其停止排队方法

##### 1. 动画或效果队列

动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。

##### 2. 停止排队

```javascript
stop()
```

(1）stop() 方法用于停止动画或效果。

(2) 注意： stop() 写到动画或者效果的前面， 相当于**停止结束上一次的动画**。





#### 3.5 淡入淡出效果

##### 淡入效果

##### 1.淡入效果语法规范

```javascript
fadeIn([speed,[easing],[fn]])
```

##### 2.淡入效果参数

（1）参数都可以省略。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 淡出效果

##### 1.淡出效果语法规范

```javascript
fadeOut([speed,[easing],[fn]])
```

##### 2. 淡出效果参数

（1）参数都可以省略。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 淡入淡出切换效果

##### 1. 淡入淡出切换效果语法规范

```javascript
fadeToggle([speed,[easing],[fn]])
```

##### 2. 淡入淡出切换效果参数

（1）参数都可以省略。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。



##### 淡入淡出的渐进方式调整

##### 1. 渐进方式调整到指定不透明度

```javascript
fadeTo([[speed],opacity,[easing],[fn]])
```

##### 效果参数

（1）**opacity 透明度必须写，取值 0~1 之间。**

（2）**speed**：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。必须写

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。





#### 3.6 自定义动画

##### 1. 语法

```javascript
animate(params,[speed],[easing],[fn])
```

##### 2. 参数

（1）**params: 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采取驼峰命名法 borderLeft**。其余参数都可以省略。

（2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。

（3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。

（4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。





#### 案例：王者荣耀手风琴效果

**案例分析**

①鼠标经过某个小li 有两步操作：

②当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入

③其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出







### jQuery 属性操作

#### 4.1 设置或获取元素固有属性值prop()

所谓元素固有属性就是元素本身自带的属性，比如 <a\> 元素里面的 href ，比如 <input\> 元素里面的 type。 

##### 1. 获取属性语法

```javascript
prop(''属性'')
```

##### 2. 设置属性语法

```javascript
prop(''属性'', ''属性值'')
```



#### 4.2 设置或获取元素自定义属性值 attr()

用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 

##### 1. 获取属性语法

```javascript
attr(''属性'')      // 类似原生 getAttribute()
```

##### 2. 设置属性语法

```javascript
attr(''属性'', ''属性值'')   // 类似原生 setAttribute()
```

该方法也可以获取 H5 自定义属性





#### 4.3 数据缓存 data()

data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 

##### 1. 附加数据语法

```javascript
data(''name'',''value'')   // 向被选元素附加数据   
```

##### 2. 获取数据语法

```javascript
date(''name'')             //   向被选元素获取数据   
```

同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型





#### 案例：购物车案例模块-全选

**案例分析**

①全选思路：里面3个小的复选框按钮（j-checkbox）选中状态（checked）跟着全选按钮（checkall）走。

②因为checked 是复选框的固有属性，此时我们需要利用prop()方法获取和设置该属性。

③把全选按钮状态赋值给3小复选框就可以了。

④当我们每次点击小的复选框按钮，就来判断：

⑤如果小复选框被选中的个数等于3 就应该把全选按钮选上，否则全选按钮不选。

⑥:checked 选择器   :checked 查找被选中的表单元素。







### 5. jQuery 内容文本值

主要针对元素的**内容**还有**表单的值**操作。

#### 1. 普通元素内容 html() （相当于原生innerHTML）

```javascript
html()             // 获取元素的内容
```

```javascript
html(''内容'')   // 设置元素的内容
```

#### 2. 普通元素文本内容 text()（相当于原生 innerText）

```javascript
text()                     // 获取元素的文本内容
```

```javascript
text(''文本内容'')   // 设置元素的文本内容
```

#### 3. 表单的值 val()（相当于原生value）

```javascript
val()              // 获取表单的值
```

```javascript
val(''内容'')   // 设置表单的值
```



#### 案例：购物车案例模块-增减商品数量

**案例分析**

① 核心思路：首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。

② 注意1： 只能增加本商品的数量， 就是当前+号的兄弟文本框（itxt）的值。 

③ 修改表单的值是val() 方法

④ 注意2： 这个变量初始值应该是这个文本框的值，在这个值的基础上++。要获取表单的值

⑤ 减号（decrement）思路同理，但是如果文本框的值是1，就不能再减了。



#### 案例：购物车案例模块-修改商品小计

**案例分析**

① 核心思路：每次点击+号或者-号，根据文本框的值 乘以 当前商品的价格 就是 商品的小计

② 注意1： 只能增加本商品的小计， 就是当前商品的小计模块（p-sum） 

③ 修改普通元素的内容是text() 方法

④ 注意2： 当前商品的价格，要把￥符号去掉再相乘 截取字符串 substr(1)

⑤ parents(‘选择器’) 可以返回指定祖先元素 

⑥ 最后计算的结果如果想要保留2位小数 通过 toFixed(2) 方法

⑦ 用户也可以直接修改表单里面的值，同样要计算小计。 用表单change事件

⑧ 用最新的表单内的值 乘以 单价即可 但是还是当前商品小计







### 6. jQuery 元素操作

主要是遍历、创建、添加、删除元素操作。

#### 6.1 遍历元素

jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。

**语法1：**

```javascript
$("div").each(function (index, domEle) { xxx; }）       
```

1. each() 方法遍历匹配的每一个元素。主要用DOM处理。 each 每一个

2. 里面的回调函数有2个参数： index 是每个元素的索引号; demEle 是每个**DOM元素对象，不是jquery对象**

3. **所以要想使用jquery方法，需要给这个dom元素转换为jquery对象 $(domEle)**



**语法2：**

```javascript
$.each(object，function (index, element) { xxx; }）       
```

1. $.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象

2. 里面的函数有2个参数： index 是每个元素的索引号; element 遍历内容



#### 案例：购物车案例模块-计算总计和总额

① 核心思路：把所有文本框里面的值相加就是总计数量。总额同理

② 文本框里面的值不相同，如果想要相加需要用到each遍历。声明一个变量，相加即可

③ 点击+号-号，会改变总计和总额，如果用户修改了文本框里面的值同样会改变总计和总额

④ 因此可以封装一个函数求总计和总额的， 以上2个操作调用这个函数即可。

⑤ 注意1： 总计是文本框里面的值相加用 val()   总额是普通元素的内容用text() 

⑥ 要注意普通元素里面的内容要去掉￥并且转换为数字型才能相加





#### 6.2 创建元素

**语法：**

```javascript
$("<li></li>");    
```

动态的创建了一个 <li\> 





#### 6.4 添加元素

##### 1. 内部添加

```javascript
element.append(''内容'')  
```

把内容放入匹配元素内部最**后面**，类似原生 appendChild。



```javascript
element.prepend(''内容'')  
```

把内容放入匹配元素内部最前面。



##### 2. 外部添加

```javascript
element.after(''内容'')        //  把内容放入目标元素后面
```

```javascript
element.before(''内容'')    //  把内容放入目标元素前面 
```

**① 内部添加元素，生成之后，它们是父子关系。**

**② 外部添加元素，生成之后，他们是兄弟关系。**





#### 6.4 删除元素

```javascript
element.remove()   //  删除匹配的元素（本身）
```

```javascript
element.empty()    //  删除匹配的元素集合中所有的子节点
```

```javascript
element.html("")   //  清空匹配的元素内容
```

**① remove 删除元素本身。**

**② empty() 和 html('''') 作用等价，都可以删除元素里面的内容，只不过 html 还可以设置内容。**





#### 案例：购物车案例模块-删除商品模块

① 核心思路：把商品remove() 删除元素即可

② 有三个地方需要删除： 1. 商品后面的删除按钮 2. 删除选中的商品 3. 清理购物车

③ 商品后面的删除按钮： 一定是删除当前的商品，所以从 $(this) 出发

④ 删除选中的商品： 先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品

⑤ 清理购物车： 则是把所有的商品全部删掉



#### 案例：购物车案例模块-选中商品添加背景

① 核心思路：选中的商品添加背景，不选中移除背景即可

② 全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景

③ 小的复选框点击： 如果是选中状态，则当前商品添加背景，否则移除背景

④ 这个背景，可以通过类名修改，添加类和删除类







### 7. jQuery 尺寸、位置操作

#### 7.1 jQuery 尺寸

| 语法                                 | 用法                                                 |
| ------------------------------------ | ---------------------------------------------------- |
| width() / height()                   | 取得匹配元素宽度和高度值 width / height              |
| innerWidth() / innerHeight()         | 取得匹配元素宽度和高度值 包含padding                 |
| outerWidth() / outerHeight()         | 取得匹配元素宽度和高度值 包含padding、border         |
| outerWitsh(true) / outerHeight(true) | 取得匹配元素宽度和高度值 包含padding、border、margin |

* 以上参数为空，则是获取相应值，返回的是数字型。

* 如果参数为数字，则是修改相应值。

* 参数可以不必写单位。





#### 7.2 jQuery 位置

位置主要有三个： offset()、position()、scrollTop()/scrollLeft()

##### 1. offset() 设置或获取元素偏移

① offset() 方法设置或返回被选元素相对于**文档**的偏移坐标，跟父级没有关系。

② 该方法有2个属性 left、top 。offset().top 用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。

③ 可以设置元素的偏移：offset({ top: 10, left: 30 });

##### 2. position() 获取元素偏移

① position() 方法用于返回被选元素相对于**带有定位的父级**偏移坐标，如果父级都没有定位，则以文档为准。

② 该方法有2个属性 left、top。position().top 用于获取距离定位父级顶部的距离，position().left 用于获取距离定位父级左侧的距离。

③ 该方法只能获取。

##### 3. scrollTop()/scrollLeft() 设置或获取元素被卷去的头部和左侧

① scrollTop() 方法设置或返回被选元素被卷去的头部。

② 不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部。



##### 案例：带有动画的返回顶部

① 核心原理： 使用animate动画返回顶部。

② animate动画函数里面有个scrollTop 属性，可以设置位置

③ 但是是元素做动画，因此 $(“body,html”).animate({scrollTop: 0})



##### 案例：品优购电梯导航

**案例分析1**

① 当我们滚动到 今日推荐 模块，就让电梯导航显示出来

② 点击电梯导航页面可以滚动到相应内容区域

③ 核心算法：因为电梯导航模块和内容区模块一一对应的

④ 当我们点击电梯导航某个小模块，就可以拿到当前小模块的索引号

⑤ 就可以把animate要移动的距离求出来：当前索引号内容区模块它的offset().top

⑥ 然后执行动画即可

**案例分析2**

① 当我们点击电梯导航某个小li， 当前小li 添加current类，兄弟移除类名

② 当我们页面滚动到内容区域某个模块， 左侧电梯导航，相对应的小li模块，也会添加current类， 兄弟移除current类。

③ 触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。

④需要用到each，遍历内容区域大模块。 each里面能拿到内容区域每一个模块元素和索引号

⑤ 判断的条件： 被卷去的头部 大于等于 内容区域里面每个模块的offset().top

⑥ 就利用这个索引号找到相应的电梯导航小li添加类。









****

## jQuery 事件

### 1. jQuery 事件注册

#### 单个事件注册

**语法：**

```javascript
element.事件(function(){})       
```

```javascript
$(“div”).click(function(){  事件处理程序 })       
```

其他事件和原生基本一致。

比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等





### 2. jQuery 事件处理

#### 2.1 事件处理 on() 绑定事件

on() 方法在匹配元素上绑定一个或多个事件的事件处理函数

**语法：**

```javascript
element.on(events,[selector],fn)       
```

1. events:一个或多个用空格分隔的事件类型，如"click"或"keydown" 。

2. selector: 元素的子元素选择器 。

3. fn:回调函数 即绑定在元素身上的侦听函数。 



##### on() 方法优势1：

可以绑定多个事件，多个处理事件处理程序。 

```javascript
 $(“div”).on({
  mouseover: function(){}, 
  mouseout: function(){},
  click: function(){}	
});       
```

如果事件处理程序相同

```javascript
 $(“div”).on(“mouseover mouseout”, function() {
   $(this).toggleClass(“current”);
  });       
```



##### on() 方法优势2：

可以事件委派操作 。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。

```javascript
$('ul').on('click', 'li', function() {
    alert('hello world!');
});       
```

在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派，最新版本的请用**on**替代他们。



##### on() 方法优势3：

动态创建的元素，click() 没有办法绑定事件， on() 可以给动态生成的元素绑定事件 

```javascript
 $(“div").on("click",”p”, function(){
     alert("俺可以给动态生成的元素绑定事件")
 });       
```

```javascript
 $("div").append($("<p>我是动态创建的p</p>"));
```



##### 案例：发布微博案例

① 点击发布按钮， 动态创建一个小li，放入文本框的内容和删除按钮， 并且添加到ul 中。

② 点击的删除按钮，可以删除当前的微博留言。





#### 2.2 事件处理 off() 解绑事件

off() 方法可以移除通过 on() 方法添加的事件处理程序。

```javascript
$("p").off() // 解绑p元素所有事件处理程序

$("p").off( "click")  // 解绑p元素上面的点击事件 后面的 foo 是侦听函数名

$("ul").off("click", "li");   // 解绑事件委托

```

如果有的事件只想触发一次， 可以使用 one() 来绑定事件。





#### 2.3 自动触发事件 trigger()

有些事件希望自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。

```javascript
element.click()  // 第一种简写形式
```

```javascript
element.trigger("type") // 第二种自动触发模式
```

```javascript
$("p").on("click", function () {
  alert("hi~");
}); 

$("p").trigger("click"); // 此时自动触发点击事件，不需要鼠标点击
```

```javascript
element.triggerHandler(type)  // 第三种自动触发模式
```

triggerHandler模式不会触发元素的默认行为，这是和前面两种的区别。







### 3. jQuery 事件对象

事件被触发，就会有事件对象的产生。

```javascript
element.on(events,[selector],function(event) {})       
```

阻止默认行为：event.preventDefault()  或者 return false 

阻止冒泡： event.stopPropagation()   









***

## jQuery 其他方法

### 1. jQuery 对象拷贝

如果想要把某个对象拷贝（合并） 给另外一个对象使用，此时可以使用 $.extend() 方法

**语法：**

```javascript
$.extend([deep], target, object1, [objectN])    
```

1. deep: 如果设为true 为深拷贝， 默认为false 浅拷贝 

2. target: 要拷贝的目标对象

3. object1:待拷贝到第一个对象的对象。

4. objectN:待拷贝到第N个对象的对象。

5. 浅拷贝是把被拷贝的对象**复杂数据类型中的地址**拷贝给目标对象，修改目标对象**会影响**被拷贝对象。

6. 深拷贝，前面加true， 完全克隆(拷贝的对象,而不是地址)，修改目标对象**不会影响**被拷贝对象。





### 2. jQuery 多库共存

**问题概述：**

jQuery使用$作为标示符，随着jQuery的流行,其他 js 库也会用这$作为标识符， 这样一起使用会引起冲突。

**客观需求：**

需要一个解决方案，让jQuery 和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。

**jQuery 解决方案：**

**1. 把里面的 $ 符号 统一改为 jQuery。 比如 jQuery(''div'')**

**2.  jQuery 变量规定新的名称：$.noConflict()    var xx = $.noConflict();**







### 3. jQuery 插件

jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。

注意: 这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为 jQuery 插件。

**jQuery** **插件常用的网站：**

1. jQuery 插件库 http://www.jq22.com/   

2. jQuery 之家  http://www.htmleaf.com/ 

**jQuery** **插件使用步骤：**

1. 引入相关文件。（jQuery 文件 和 插件文件）  

2. 复制相关html、css、js (调用插件)。

**jQuery** **插件演示：**

1. 瀑布流

2. 图片懒加载（图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载）

 当我们页面滑动到可视区域，再显示图片。

 我们使用jquery 插件库 EasyLazyload。 注意，此时的js引入文件和js调用必须写到 DOM元素（图片）最后面

3. 全屏滚动（fullpage.js）

   gitHub： https://github.com/alvarotrigo/fullPage.js

   中文翻译网站： http://www.dowebok.com/demo/2014/77/

**bootstrap JS** **插件：**

bootstrap 框架也是依赖于 jQuery 开发的，因此里面的 js插件使用 ，也必须引入jQuery 文件。



#### 案例：toDoList

① 文本框里面输入内容，按下回车，就可以生成待办事项。

② 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。

③ 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。

**④ 但是本页面内容刷新页面不会丢失。**

**案例分析**

① 刷新页面不会丢失数据，因此需要用到本地存储 localStorage

② **核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据**

③ 存储的数据格式：var todolist =  [{ title : ‘xxx’, done: false}]

④ 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。

⑤ 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。



##### 案例：tiDoList 按下回车把新数据添加到本地存储里面

① 切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。

② 利用事件对象.keyCode判断用户按下回车键（13）。

③ 声明一个数组，保存数据。

④ 先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。

⑤ 之后把最新从表单获取过来的数据，追加到数组里面。

⑥ 最后把数组存储给本地存储 (声明函数 savaDate())



##### 案例：toDoList 本地存储数据渲染加载到页面

① 因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用

② 先要读取本地存储数据。（数据不要忘记转换为对象格式）

③ 之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。

④ 每次渲染之前，先把原先里面 ol 的**内容**清空，然后渲染加载最新的数据。



##### 案例：toDoList 删除操作

① 点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。

**② 核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li**

③ 我们可以给链接自定义属性记录当前的索引号

④ 根据这个索引号删除相关的数据----数组的splice(i, 1)方法

⑤ 存储修改后的数据，然后存储给本地存储

⑥ 重新渲染加载数据列表

⑦ 因为a是动态创建的，我们使用on方法绑定事件



##### 案例：toDoList 正在进行和已完成选项操作

**① 当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。**

② 点击之后，获取本地存储数据。

③ 修改对应数据属性 done 为当前复选框的checked状态。

④ 之后保存数据到本地存储

⑤ 重新渲染加载数据列表

⑥ load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面

⑦ 如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面



##### 案例：toDoList 统计正在进行个数和和已完成个数

① 在我们load 函数里面操作

② 声明2个变量 ：todoCount 待办个数 doneCount 已完成个数  

③ 当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++

④ 最后修改相应的元素 text()









***

















